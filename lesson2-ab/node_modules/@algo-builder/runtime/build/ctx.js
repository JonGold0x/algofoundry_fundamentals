"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ctx = void 0;
/* eslint-disable */
const web_1 = require("@algo-builder/web");
const algosdk_1 = __importStar(require("algosdk"));
const _1 = require(".");
const account_1 = require("./account");
const errors_list_1 = require("./errors/errors-list");
const runtime_errors_1 = require("./errors/runtime-errors");
const asa_1 = require("./lib/asa");
const constants_1 = require("./lib/constants");
const txn_1 = require("./lib/txn");
const tx_1 = require("./mock/tx");
const parser_1 = require("./parser/parser");
const types_1 = require("./types");
const APPROVAL_PROGRAM = "approval-program";
const CLEAR_PROGRAM = "clear-state-program";
class Ctx {
    // know the transaction type of current transaction in execution.
    constructor(state, tx, gtxs, args, runtime, debugStack) {
        this.state = state;
        this.tx = tx;
        this.gtxs = gtxs;
        this.args = args;
        this.runtime = runtime;
        this.debugStack = debugStack;
        this.lastLog = new Uint8Array([]);
        // Mapping from the tx index number to the scratch space.
        // Scratch space is a list of elements.
        this.sharedScratchSpace = new Map();
        this.knowableID = new Map();
        this.pooledApplCost = 0;
        // inner transaction props
        this.isInnerTx = false;
        // initial app call stack
        this.innerTxAppIDCallStack = [tx.apid ?? 0];
        this.remainingFee = 0;
        this.remainingTxns = 256;
        this.budget = constants_1.MAX_APP_PROGRAM_COST;
        this.txnType = undefined;
    }
    setAndGetTxReceipt() {
        const info = { txn: this.tx, txID: this.tx.txID };
        this.state.txReceipts.set(this.tx.txID, info);
        return info;
    }
    // verify account's balance is above minimum required balance
    assertAccBalAboveMin(address) {
        const account = this.getAccount(address);
        if (account.balance() < account.minBalance && this.txnType == algosdk_1.TransactionType.pay) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TRANSACTION.INSUFFICIENT_ACCOUNT_BALANCE, {
                accBalance: account.balance(),
                address: address,
                minbalance: account.minBalance,
            });
        }
    }
    // verifies assetId is not frozen for an account
    assertAssetNotFrozen(assetIndex, address) {
        const assetHolding = this.getAssetHolding(assetIndex, address);
        if (assetHolding["is-frozen"]) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TRANSACTION.ACCOUNT_ASSET_FROZEN, {
                assetId: assetIndex,
                address: address,
            });
        }
    }
    /**
     * Asserts program length. maxPossible = MaxAppProgramLen * (1 + extraPages)
     * @param approvalProgramBytes Approval program bytes
     * @param clearProgramBytes Clear program bytes
     * @param extraPages Extra pages. Default extra page is 0.
     */
    assertProgramMaxLen(approvalProgramBytes, clearProgramBytes, extraPages = 0) {
        const approvalProgramLength = approvalProgramBytes.length;
        const clearProgramLengthProgram = clearProgramBytes.length;
        const approvalClearProgramLength = approvalProgramLength + clearProgramLengthProgram;
        const maxPossible = constants_1.MaxAppProgramLen * (1 + extraPages);
        if (approvalClearProgramLength > maxPossible) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.MAX_LEN_EXCEEDED, {
                length: approvalClearProgramLength,
                maxlen: maxPossible,
                mode: "Stateful",
            });
        }
    }
    // verify approval program and clear state program build in same version
    verifyTEALVersionIsMatch(approvalProg, clearProgram) {
        const approvalVersion = (0, parser_1.getProgramVersion)(approvalProg);
        const clearVersion = (0, parser_1.getProgramVersion)(clearProgram);
        if (approvalVersion !== clearVersion) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.PROGRAM_VERSION_MISMATCH, {
                approvalVersion,
                clearVersion,
            });
        }
    }
    /**
     * Fetches account from `runtime.ctx`
     * @param address account address
     */
    getAccount(address) {
        const account = this.state.accounts.get(address);
        return this.runtime.assertAccountDefined(address, account);
    }
    /**
     * Returns asset creator account from runtime.ctx or throws error is it doesn't exist
     * @param assetId Asset Index
     */
    getAssetAccount(assetId) {
        const addr = this.state.assetDefs.get(assetId);
        if (addr === undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.ASSET_NOT_FOUND, { assetId: assetId });
        }
        return this.runtime.assertAccountDefined(addr, this.state.accounts.get(addr));
    }
    /**
     * Returns Asset Definitions
     * @param assetId Asset Index
     */
    getAssetDef(assetId) {
        const creatorAcc = this.getAssetAccount(assetId);
        const assetDef = creatorAcc.getAssetDef(assetId);
        return this.runtime.assertAssetDefined(assetId, assetDef);
    }
    /**
     * Returns Asset Holding from an account
     * @param assetIndex Asset Index
     * @param address address of account to get holding from
     */
    getAssetHolding(assetIndex, address) {
        const account = this.runtime.assertAccountDefined(address, this.state.accounts.get(address));
        const assetHolding = account.getAssetHolding(assetIndex);
        if (assetHolding === undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TRANSACTION.ASA_NOT_OPTIN, {
                assetId: assetIndex,
                address: address,
            });
        }
        return assetHolding;
    }
    /**
     * Fetches app from `ctx state`
     * @param appID Application Index'
     * @param line Line number in teal file
     */
    getApp(appID, line) {
        const lineNumber = line ?? "unknown";
        if (!this.state.globalApps.has(appID)) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.APP_NOT_FOUND, {
                appID: appID,
                line: lineNumber,
            });
        }
        const accAddress = this.runtime.assertAddressDefined(this.state.globalApps.get(appID));
        const account = this.runtime.assertAccountDefined(accAddress, this.state.accounts.get(accAddress));
        return this.runtime.assertAppDefined(appID, account.getApp(appID));
    }
    getCallerApplicationID() {
        let callerApplicationID = 0;
        // when the top value in the `innerTxAppIDCallStack` is the own appID
        // not the caller appID(we need to get the second top one)
        if (this.innerTxAppIDCallStack.length > 1) {
            callerApplicationID = this.innerTxAppIDCallStack[this.innerTxAppIDCallStack.length - 2];
        }
        return callerApplicationID;
    }
    getCallerApplicationAddress() {
        const callerApplicationID = this.getCallerApplicationID();
        if (callerApplicationID === 0)
            return constants_1.ZERO_ADDRESS_STR;
        return (0, algosdk_1.getApplicationAddress)(callerApplicationID);
    }
    // transfer ALGO as per transaction parameters
    transferAlgo(transaction) {
        const fromAccount = this.getAccount(web_1.tx.getTxFromAddress(transaction));
        const toAccount = this.getAccount(web_1.tx.getTxToAddress(transaction));
        fromAccount.amount -= BigInt(transaction.amount); // remove 'x' algo from sender
        toAccount.amount += BigInt(transaction.amount); // add 'x' algo to receiver
        this.assertAccBalAboveMin(fromAccount.address);
        const closeRemainderToAddress = web_1.tx.getTxCloseReminderToAddress(transaction);
        if (closeRemainderToAddress !== undefined) {
            this.verifyCloseRemainderTo(transaction);
            const closeReminderToAccount = this.getAccount(closeRemainderToAddress);
            // transfer funds of sender to closeRemTo account
            closeReminderToAccount.amount += fromAccount.amount;
            fromAccount.amount = 0n; // close sender's account
        }
        return this.setAndGetTxReceipt();
    }
    /**
     * Deploy asset using asa.yaml file
     * @param name asset name
     * @param fromAccountAddr account address
     * @param flags asa deployment flags
     */
    deployASA(name, fromAccountAddr, flags) {
        if (this.runtime.loadedAssetsDefs === undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.ASA_FILE_IS_UNDEFINED);
        }
        if (this.runtime.loadedAssetsDefs[name] === undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.ASA_DEFINITION_NO_FOUND_IN_ASA_FILE);
        }
        return this.deployASADef(name, this.runtime.loadedAssetsDefs[name], fromAccountAddr, flags);
    }
    /**
     * Deploy Asset without using asa.yaml file
     * @param name ASA name
     * @param asaDef asset defitions
     * @param fromAccountAddr account address of creator
     * @param flags ASA Deployment Flags
     */
    deployASADef(name, asaDef, fromAccountAddr, flags) {
        const senderAcc = this.getAccount(fromAccountAddr);
        (0, _1.parseASADef)(asaDef);
        (0, asa_1.validateOptInAccNames)(this.state.accountNameAddress, asaDef);
        // create asset(with holding) in sender account
        const asset = senderAcc.addAsset(++this.state.assetCounter, name, asaDef);
        this.assertAccBalAboveMin(fromAccountAddr);
        this.runtime.mkAssetCreateTx(name, flags, asset);
        this.state.assetDefs.set(this.state.assetCounter, senderAcc.address);
        const asaInfo = {
            creator: senderAcc.address,
            assetIndex: this.state.assetCounter,
            assetDef: asset,
            txID: this.tx.txID,
            confirmedRound: this.runtime.getRound(),
            deleted: false,
        };
        this.state.assetNameInfo.set(name, asaInfo);
        // set & return transaction receipt
        this.state.txReceipts.set(this.tx.txID, asaInfo);
        return asaInfo;
    }
    /**
     * Asset Opt-In for account in context
     * @param assetIndex Asset Index
     * @param address Account address to opt-into asset
     * @param flags Transaction Parameters
     */
    optInToASA(assetIndex, address, flags) {
        const assetDef = this.getAssetDef(assetIndex);
        (0, algosdk_1.makeAssetTransferTxnWithSuggestedParams)(address, address, undefined, undefined, 0, undefined, assetIndex, (0, tx_1.mockSuggestedParams)(flags, this.runtime.getRound()));
        const assetHolding = {
            amount: 0n,
            "asset-id": assetIndex,
            creator: assetDef.creator,
            "is-frozen": assetDef.defaultFrozen ? assetDef.defaultFrozen : false,
        };
        const account = this.getAccount(address);
        account.optInToASA(assetIndex, assetHolding);
        this.assertAccBalAboveMin(address);
        return this.setAndGetTxReceipt();
    }
    /**
     * deploy a new application and returns application id
     * @param creatorAddr creator account address
     * @param appDefinition source of approval and clear program
     * @param idx index of transaction in group
     * @param scTmplParams Smart Contract template parameters
     * NOTE When creating or opting into an app, the minimum balance grows before the app code runs
     */
    deployApp(creatorAddr, appDefinition, idx, scTmplParams) {
        const senderAcc = this.getAccount(creatorAddr);
        if (appDefinition.metaType === web_1.types.MetaType.BYTES) {
            throw new Error("not support this format");
        }
        const approvalFile = appDefinition.metaType === web_1.types.MetaType.FILE
            ? appDefinition.approvalProgramFilename
            : appDefinition.approvalProgramCode;
        const clearFile = appDefinition.metaType === web_1.types.MetaType.FILE
            ? appDefinition.clearProgramFilename
            : appDefinition.clearProgramCode;
        const approvalProgTEAL = appDefinition.metaType === web_1.types.MetaType.FILE
            ? (0, _1.getProgram)(appDefinition.approvalProgramFilename, "", scTmplParams)
            : appDefinition.approvalProgramCode;
        const clearProgTEAL = appDefinition.metaType === web_1.types.MetaType.FILE
            ? (0, _1.getProgram)(appDefinition.clearProgramFilename, "", scTmplParams)
            : appDefinition.clearProgramCode;
        if (approvalProgTEAL === "") {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.INVALID_APPROVAL_PROGRAM);
        }
        if (clearProgTEAL === "") {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.INVALID_CLEAR_PROGRAM);
        }
        const approvalProgramBytes = Buffer.from(approvalProgTEAL, "base64");
        const clearProgramBytes = Buffer.from(clearProgTEAL, "base64");
        this.assertProgramMaxLen(approvalProgramBytes, clearProgramBytes, appDefinition.extraPages);
        this.verifyTEALVersionIsMatch(approvalProgTEAL, clearProgTEAL);
        //verify that MaxGlobalSchemaEntries <= 64 and MaxLocalSchemaEntries <= 16
        const globalSchemaEntries = appDefinition.globalInts + appDefinition.globalBytes;
        const localSchemaEntries = appDefinition.localInts + appDefinition.localBytes;
        if (localSchemaEntries > constants_1.MAX_LOCAL_SCHEMA_ENTRIES ||
            globalSchemaEntries > constants_1.MAX_GLOBAL_SCHEMA_ENTRIES) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.MAX_SCHEMA_ENTRIES_EXCEEDED, {
                localState: localSchemaEntries,
                localMax: constants_1.MAX_LOCAL_SCHEMA_ENTRIES,
                globalState: globalSchemaEntries,
                globalMax: constants_1.MAX_GLOBAL_SCHEMA_ENTRIES,
            });
        }
        // create app with id = 0 in globalApps for teal execution
        const app = senderAcc.addApp(0, {
            ...appDefinition,
            metaType: web_1.types.MetaType.SOURCE_CODE,
            approvalProgramCode: approvalProgTEAL,
            clearProgramCode: clearProgTEAL,
        });
        this.assertAccBalAboveMin(senderAcc.address);
        this.state.accounts.set(senderAcc.address, senderAcc);
        this.state.globalApps.set(app.id, senderAcc.address);
        // execute TEAL code with appID = 0
        this.runtime.run(approvalProgTEAL, types_1.ExecutionMode.APPLICATION, idx, this.debugStack);
        // create new application in globalApps map
        this.state.globalApps.set(++this.state.appCounter, senderAcc.address);
        const attributes = this.getApp(0);
        senderAcc.createdApps.delete(0); // remove zero app from sender's account
        this.state.globalApps.delete(0); // remove zero app from context
        senderAcc.createdApps.set(this.state.appCounter, attributes);
        const appInfo = {
            creator: senderAcc.address,
            appID: this.state.appCounter,
            applicationAccount: (0, algosdk_1.getApplicationAddress)(this.state.appCounter),
            txID: this.tx.txID,
            confirmedRound: this.runtime.getRound(),
            timestamp: Math.round(+new Date() / 1000),
            deleted: false,
            // we don't have access to bytecode in runtime
            approvalFile,
            clearFile,
        };
        this.state.appNameMap.set(approvalFile + "-" + clearFile, appInfo);
        if (approvalFile + "-" + clearFile !== appDefinition.appName &&
            this.state.appNameMap.get(appDefinition.appName) !== undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.APP_NAME_ALREADLY_USED, {
                appName: appDefinition.appName,
            });
        }
        this.state.appNameMap.set(appDefinition.appName, appInfo);
        const acc = new _1.AccountStore(0, new account_1.RuntimeAccount({
            addr: (0, algosdk_1.getApplicationAddress)(this.state.appCounter),
            sk: new Uint8Array(0),
        }));
        this.state.accounts.set(acc.address, acc);
        // return transaction receipt
        return appInfo;
    }
    /**
     * Account address opt-in for application Id
     * @param accountAddr Account address to opt into application
     * @param appID Application index
     * @param idx index of transaction in group
     * NOTE: When creating or opting into an app, the minimum balance grows before the app code runs
     */
    optInToApp(accountAddr, appID, idx) {
        const appParams = this.getApp(appID);
        const account = this.getAccount(accountAddr);
        account.optInToApp(appID, appParams);
        this.assertAccBalAboveMin(accountAddr);
        try {
            return this.runtime.run(appParams[APPROVAL_PROGRAM], types_1.ExecutionMode.APPLICATION, idx, this.debugStack);
        }
        catch (error) {
            account.closeApp(appID); // remove already added state if optIn fails
            throw error;
        }
    }
    /**
     * Verify Pooled Transaction Fees
     * supports pooled fees where one transaction can pay the
     * fees of other transactions within an atomic group.
     * For atomic transactions, the protocol sums the number of
     * transactions and calculates the total amount of required fees,
     * then calculates the amount of fees submitted by all transactions.
     * If the collected fees are greater than or equal to the required amount,
     * the transaction fee requirement will be met.
     * https://developer.algorand.org/articles/introducing-algorand-virtual-machine-avm-09-release/
     */
    verifyMinimumFees() {
        // pooled fee for inner tx is calculated at itx_submit
        if (this.isInnerTx) {
            return;
        }
        const credit = (0, txn_1.calculateFeeCredit)(this.gtxs);
        this.remainingFee = credit.remainingFee;
        if (credit.remainingFee < 0) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TRANSACTION.FEES_NOT_ENOUGH, {
                required: credit.requiredFee,
                collected: credit.collectedFee,
            });
        }
    }
    /**
     * Verify closeRemainderTo field is different than fromAccountAddr
     * @param transaction transaction params
     */
    verifyCloseRemainderTo(transaction) {
        if (transaction.closeRemainderTo == undefined)
            return;
        if (web_1.tx.getTxCloseReminderToAddress(transaction) === web_1.tx.getTxFromAddress(transaction)) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TRANSACTION.INVALID_CLOSE_REMAINDER_TO);
        }
    }
    /**
     * Verify if the current inner transaction can be executed
     */
    verifyAndUpdateInnerAppCallStack() {
        // verify
        if (!this.isInnerTx)
            return;
        if (this.innerTxAppIDCallStack.length >= 8) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TRANSACTION.INNER_APP_DEEP_EXCEEDED);
        }
        const appID = this.tx.apid ?? 0;
        if (appID > 0 && this.innerTxAppIDCallStack.find((id) => id === appID) !== undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TRANSACTION.INNER_APP_SELF_CALL);
        }
        // update inner tx call stack
        if (appID > 0)
            this.innerTxAppIDCallStack.push(appID);
    }
    /**
     * Deduct transaction fee from sender account.
     * @param sender Sender address
     * @param index Index of current tx being processed in tx group
     */
    deductFee(sender, index, params) {
        let fee = BigInt(this.gtxs[index].fee ?? 0);
        // If flatFee boolean is not set, change fee value
        if (!params.flatFee && params.totalFee === undefined) {
            fee = BigInt(Math.max(constants_1.ALGORAND_MIN_TX_FEE, Number(this.gtxs[index].fee)));
        }
        const fromAccount = this.getAccount(sender);
        if (fromAccount.balance() < fee) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TRANSACTION.INSUFFICIENT_ACCOUNT_BALANCE, {
                accBalance: fromAccount.balance(),
                address: fromAccount.address,
                minbalance: fee,
            });
        }
        fromAccount.amount -= fee; // remove tx fee from Sender's account
        this.assertAccBalAboveMin(fromAccount.address);
    }
    // transfer ASSET as per transaction parameters
    transferAsset(transaction) {
        const fromAccountAddr = web_1.tx.getTxFromAddress(transaction);
        const toAccountAddr = web_1.tx.getTxToAddress(transaction);
        const transactionFlags = web_1.tx.getTxFlags(transaction);
        if (BigInt(transaction.amount) === 0n && fromAccountAddr === toAccountAddr) {
            this.optInToASA(transaction.assetIndex, fromAccountAddr, transactionFlags);
        }
        else if (BigInt(transaction.amount) !== 0n) {
            this.assertAssetNotFrozen(transaction.assetIndex, fromAccountAddr);
            this.assertAssetNotFrozen(transaction.assetIndex, toAccountAddr);
        }
        const fromAssetHolding = this.getAssetHolding(transaction.assetIndex, fromAccountAddr);
        const toAssetHolding = this.getAssetHolding(transaction.assetIndex, toAccountAddr);
        if (fromAssetHolding.amount - BigInt(transaction.amount) < 0) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TRANSACTION.INSUFFICIENT_ACCOUNT_ASSETS, {
                amount: transaction.amount,
                address: fromAccountAddr,
            });
        }
        fromAssetHolding.amount -= BigInt(transaction.amount);
        toAssetHolding.amount += BigInt(transaction.amount);
        if (transactionFlags.closeRemainderTo) {
            this.verifyCloseRemainderTo(transaction);
            const closeToAddr = transactionFlags.closeRemainderTo;
            if (fromAccountAddr === fromAssetHolding.creator) {
                throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.CANNOT_CLOSE_ASSET_BY_CREATOR);
            }
            this.assertAssetNotFrozen(transaction.assetIndex, closeToAddr);
            const closeRemToAssetHolding = this.getAssetHolding(transaction.assetIndex, closeToAddr);
            // transfer assets of sender to closeRemTo account
            closeRemToAssetHolding.amount += fromAssetHolding.amount;
            const fromAccount = this.getAccount(fromAccountAddr);
            fromAccount.closeAsset(transaction.assetIndex);
        }
        return this.setAndGetTxReceipt();
    }
    /**
     * https://developer.algorand.org/docs/features/asa/#modifying-an-asset
     * Modifies asset fields
     * @param assetId Asset Index
     * @param fields Asset modifying fields
     */
    modifyAsset(assetId, fields) {
        const creatorAcc = this.getAssetAccount(assetId);
        creatorAcc.modifyAsset(assetId, fields);
        return this.setAndGetTxReceipt();
    }
    /**
     * https://developer.algorand.org/docs/features/asa/#freezing-an-asset
     * Freezes assets for a target account
     * @param assetId asset index
     * @param freezeTarget target account
     * @param freezeState target state
     */
    freezeAsset(assetId, freezeTarget, freezeState) {
        const acc = this.runtime.assertAccountDefined(freezeTarget, this.state.accounts.get(freezeTarget));
        acc.setFreezeState(assetId, freezeState);
        return this.setAndGetTxReceipt();
    }
    /**
     * https://developer.algorand.org/docs/features/asa/#revoking-an-asset
     * Revoking an asset for an account removes a specific number of the asset
     * from the revoke target account.
     * @param recipient asset receiver address
     * @param assetID asset index
     * @param revocationTarget revoke target account
     * @param amount amount of assets
     */
    revokeAsset(recipient, assetID, revocationTarget, amount) {
        // Transfer assets
        const fromAssetHolding = this.getAssetHolding(assetID, revocationTarget);
        const toAssetHolding = this.getAssetHolding(assetID, recipient);
        if (fromAssetHolding.amount - amount < 0) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TRANSACTION.INSUFFICIENT_ACCOUNT_ASSETS, {
                amount: amount,
                address: revocationTarget,
            });
        }
        fromAssetHolding.amount -= amount;
        toAssetHolding.amount += amount;
        return this.setAndGetTxReceipt();
    }
    /**
     * https://developer.algorand.org/docs/features/asa/#destroying-an-asset
     * Destroy asset
     * @param assetId asset index
     */
    destroyAsset(assetId) {
        const creatorAcc = this.getAssetAccount(assetId);
        // destroy asset from creator's account
        creatorAcc.destroyAsset(assetId);
        // delete asset holdings from all accounts
        this.state.accounts.forEach((value, key) => {
            value.assets.delete(assetId);
        });
        return this.setAndGetTxReceipt();
    }
    /**
     * Delete application from account's state and global state
     * @param appID Application Index
     */
    deleteApp(appID) {
        if (!this.state.globalApps.has(appID)) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.APP_NOT_FOUND, {
                appID: appID,
                line: "unknown",
            });
        }
        const accountAddr = this.runtime.assertAddressDefined(this.state.globalApps.get(appID));
        if (accountAddr === undefined) {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.ACCOUNT_DOES_NOT_EXIST);
        }
        const account = this.runtime.assertAccountDefined(accountAddr, this.state.accounts.get(accountAddr));
        account.deleteApp(appID);
        this.state.globalApps.delete(appID);
    }
    /**
     * Closes application from account's state
     * @param sender Sender address
     * @param appID application index
     */
    closeApp(sender, appID) {
        const fromAccount = this.getAccount(sender);
        // https://developer.algorand.org/docs/reference/cli/goal/app/closeout/#search-overlay
        this.runtime.assertAppDefined(appID, this.getApp(appID));
        fromAccount.closeApp(appID); // remove app from local state
    }
    /**
     * Update application
     * @param appID application Id
     * @param appSourceCode new application source
     * @param idx index of transaction in group
     * @param scTmplParams Smart Contract template parameters
     */
    updateApp(appID, appSourceCode, idx, scTmplParams) {
        if (appSourceCode.metaType === web_1.types.MetaType.BYTES) {
            throw new Error("not support this format");
        }
        const approvalProgTEAL = appSourceCode.metaType === web_1.types.MetaType.FILE
            ? (0, _1.getProgram)(appSourceCode.approvalProgramFilename, "", scTmplParams)
            : appSourceCode.approvalProgramCode;
        const clearProgTEAL = appSourceCode.metaType === web_1.types.MetaType.FILE
            ? (0, _1.getProgram)(appSourceCode.clearProgramFilename, "", scTmplParams)
            : appSourceCode.clearProgramCode;
        if (approvalProgTEAL === "") {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.INVALID_APPROVAL_PROGRAM);
        }
        if (clearProgTEAL === "") {
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.INVALID_CLEAR_PROGRAM);
        }
        const approvalProgramBytes = Buffer.from(approvalProgTEAL, "base64");
        const clearProgramBytes = Buffer.from(clearProgTEAL, "base64");
        this.assertProgramMaxLen(approvalProgramBytes, clearProgramBytes, appSourceCode.extraPages);
        this.verifyTEALVersionIsMatch(approvalProgTEAL, clearProgTEAL);
        const appParams = this.getApp(appID);
        const txReceipt = this.runtime.run(appParams[APPROVAL_PROGRAM], types_1.ExecutionMode.APPLICATION, idx, this.debugStack);
        const updatedApp = this.getApp(appID);
        updatedApp[APPROVAL_PROGRAM] = approvalProgTEAL;
        updatedApp[CLEAR_PROGRAM] = clearProgTEAL;
        return txReceipt;
    }
    /**
     * Rekeys the account
     * @param txn transaction
     * @param rekeyTo address
     */
    rekeyTo(txn, reKeyTo) {
        if (reKeyTo === undefined)
            return;
        const fromAccount = this.getAccount(web_1.tx.getTxFromAddress(txn));
        fromAccount.rekeyTo(reKeyTo);
    }
    /**
     * Process transactions in ctx
     * - Runs TEAL code if associated with transaction
     * - Executes the transaction on ctx
     * Note: we're doing this because if any one tx in group fails,
     * then it does not affect runtime.store, otherwise we just update
     * store with ctx (if all transactions are executed successfully).
     * @param txParams Transaction Parameters
     */
    /* eslint-disable sonarjs/cognitive-complexity */
    processTransactions(signedTransactions, appDefMap, lsigMap) {
        const txReceipts = [];
        let r;
        this.verifyMinimumFees();
        this.verifyAndUpdateInnerAppCallStack();
        signedTransactions.forEach((signedTransaction, idx) => {
            const fromAccountAddr = web_1.tx.getTxFromAddress(signedTransaction.txn);
            let payFlags = {};
            payFlags = web_1.tx.getTxFlags(signedTransaction.txn);
            this.txnType = signedTransaction.txn.type;
            this.deductFee(fromAccountAddr, idx, payFlags);
            if (lsigMap !== undefined && lsigMap.get(idx) !== undefined) {
                let lsig = lsigMap.get(idx);
                this.tx = this.gtxs[idx]; // update current tx to index of stateless
                r = this.runtime.validateLsigAndRun(lsig, this.debugStack);
                this.tx = this.gtxs[0];
                //after executing stateless tx updating current tx to default (index 0)
            }
            else if (signedTransaction.msig) {
                this.runtime.validateMultisignature(signedTransaction);
            }
            else if (signedTransaction.sgnr || signedTransaction.sig) {
                this.runtime.validateSecretKeySignature(signedTransaction);
            }
            //verify and reduce number remain Txn
            if (this.remainingTxns > 0) {
                this.remainingTxns--;
            }
            else {
                throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.GENERAL.TOO_MANY_INNER_TXN);
            }
            // https://developer.algorand.org/docs/features/asc1/stateful/#the-lifecycle-of-a-stateful-smart-contract
            switch (signedTransaction.txn.type) {
                case algosdk_1.TransactionType.pay: {
                    // if toAccountAddre doesn't exist in runtime env
                    // then we will add it to runtime env.
                    if (this.state.accounts.get(algosdk_1.default.encodeAddress(signedTransaction.txn.to.publicKey)) === undefined) {
                        this.state.accounts.set(algosdk_1.default.encodeAddress(signedTransaction.txn.to.publicKey), new _1.AccountStore(0, {
                            addr: algosdk_1.default.encodeAddress(signedTransaction.txn.to.publicKey),
                            sk: new Uint8Array(0),
                        }));
                    }
                    r = this.transferAlgo(signedTransaction.txn);
                    break;
                }
                case algosdk_1.TransactionType.keyreg: {
                    // noop
                    r = { txn: this.tx, txID: this.tx.txID };
                    break;
                }
                case algosdk_1.TransactionType.appl: {
                    switch (signedTransaction.txn.appOnComplete) {
                        case algosdk_1.default.OnApplicationComplete.NoOpOC: {
                            //deployApp
                            if ((0, txn_1.isEncTxApplicationCreate)(signedTransaction.txn.get_obj_for_encoding())) {
                                this.tx = this.gtxs[idx]; // update current tx to the requested index
                                if (appDefMap === undefined) {
                                    throw new Error("App definition needs to be provided");
                                }
                                r = this.deployApp(fromAccountAddr, appDefMap.get(idx), idx);
                                this.knowableID.set(idx, r.appID);
                            }
                            else {
                                this.tx = this.gtxs[idx]; // update current tx to the requested index
                                const appParams = this.getApp(signedTransaction.txn.appIndex);
                                r = this.runtime.run(appParams[APPROVAL_PROGRAM], types_1.ExecutionMode.APPLICATION, idx, this.debugStack);
                            }
                            break;
                        }
                        case algosdk_1.default.OnApplicationComplete.ClearStateOC: {
                            this.tx = this.gtxs[idx]; // update current tx to the requested index
                            const appParams = this.runtime.assertAppDefined(signedTransaction.txn.appIndex, this.getApp(signedTransaction.txn.appIndex));
                            try {
                                r = this.runtime.run(appParams["clear-state-program"], types_1.ExecutionMode.APPLICATION, idx, this.debugStack);
                            }
                            catch (error) {
                                // if transaction type is Clear Call,
                                // remove the app without throwing an error (rejecting tx)
                                // tested by running on algorand network
                            }
                            // remove app from local state
                            this.closeApp(fromAccountAddr, signedTransaction.txn.appIndex);
                            break;
                        }
                        case algosdk_1.default.OnApplicationComplete.CloseOutOC: {
                            this.tx = this.gtxs[idx]; // update current tx to the requested index
                            const appParams = this.getApp(signedTransaction.txn.appIndex);
                            r = this.runtime.run(appParams[APPROVAL_PROGRAM], types_1.ExecutionMode.APPLICATION, idx, this.debugStack);
                            this.closeApp(fromAccountAddr, signedTransaction.txn.appIndex);
                            break;
                        }
                        case algosdk_1.default.OnApplicationComplete.DeleteApplicationOC: {
                            this.tx = this.gtxs[idx]; // update current tx to the requested index
                            const appParams = this.getApp(signedTransaction.txn.appIndex);
                            r = this.runtime.run(appParams[APPROVAL_PROGRAM], types_1.ExecutionMode.APPLICATION, idx, this.debugStack);
                            this.deleteApp(signedTransaction.txn.appIndex);
                            break;
                        }
                        case algosdk_1.default.OnApplicationComplete.OptInOC: {
                            this.tx = this.gtxs[idx]; // update current tx to tx being exectuted in group
                            r = this.optInToApp(fromAccountAddr, signedTransaction.txn.appIndex, idx);
                            break;
                        }
                        case algosdk_1.default.OnApplicationComplete.UpdateApplicationOC: {
                            this.tx = this.gtxs[idx]; // update current tx to the requested index
                            if (appDefMap === undefined) {
                                throw new Error("Not supported");
                            }
                            r = this.updateApp(signedTransaction.txn.appIndex, appDefMap.get(idx), idx);
                            break;
                        }
                    }
                    break;
                }
                case algosdk_1.TransactionType.acfg: {
                    if ((0, txn_1.isEncTxAssetCreate)(signedTransaction.txn.get_obj_for_encoding())) {
                        this.tx = this.gtxs[idx]; // update current tx to the requested index
                        const senderAcc = this.getAccount(fromAccountAddr);
                        const flags = {
                            ...payFlags,
                            creator: { ...senderAcc.account, name: senderAcc.address },
                        };
                        r = this.deployASADef(signedTransaction.txn.assetName, web_1.tx.getTxASADefinition(signedTransaction.txn), fromAccountAddr, flags);
                        this.knowableID.set(idx, r.assetIndex);
                    }
                    else if ((0, txn_1.isEncTxAssetReconfigure)(signedTransaction.txn.get_obj_for_encoding())) {
                        const asset = this.getAssetDef(signedTransaction.txn.assetIndex);
                        if (asset.manager !== fromAccountAddr) {
                            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.MANAGER_ERROR, {
                                address: asset.manager,
                            });
                        }
                        // modify asset in ctx.
                        r = this.modifyAsset(signedTransaction.txn.assetIndex, web_1.tx.getAssetReconfigureFields(signedTransaction.txn));
                    }
                    else if ((0, txn_1.isEncTxAssetDeletion)(signedTransaction.txn.get_obj_for_encoding())) {
                        const asset = this.getAssetDef(signedTransaction.txn.assetIndex);
                        if (asset.manager !== fromAccountAddr) {
                            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.MANAGER_ERROR, {
                                address: asset.manager,
                            });
                        }
                        r = this.destroyAsset(signedTransaction.txn.assetIndex);
                    }
                    break;
                }
                case algosdk_1.TransactionType.axfer: {
                    if ((0, txn_1.isEncTxAssetTransfer)(signedTransaction.txn.get_obj_for_encoding())) {
                        r = this.transferAsset(signedTransaction.txn);
                    }
                    else if ((0, txn_1.isEncTxAssetRevoke)(signedTransaction.txn.get_obj_for_encoding())) {
                        const asset = this.getAssetDef(signedTransaction.txn.assetIndex);
                        if (asset.clawback !== fromAccountAddr) {
                            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.CLAWBACK_ERROR, {
                                address: asset.clawback,
                            });
                        }
                        if (payFlags.closeRemainderTo) {
                            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.CANNOT_CLOSE_ASSET_BY_CLAWBACK);
                        }
                        r = this.revokeAsset(web_1.tx.getTxToAddress(signedTransaction.txn), signedTransaction.txn.assetIndex, web_1.tx.getTxRevokeAddress(signedTransaction.txn), BigInt(signedTransaction.txn.amount));
                    }
                    else if ((0, txn_1.isEncTxAssetOptIn)(signedTransaction.txn.get_obj_for_encoding())) {
                        r = this.optInToASA(signedTransaction.txn.assetIndex, fromAccountAddr, payFlags);
                    }
                    break;
                }
                case algosdk_1.TransactionType.afrz: {
                    const asset = this.getAssetDef(signedTransaction.txn.assetIndex);
                    if (asset.freeze !== fromAccountAddr) {
                        throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.ASA.FREEZE_ERROR, { address: asset.freeze });
                    }
                    r = this.freezeAsset(signedTransaction.txn.assetIndex, web_1.tx.getTxFreezeAddress(signedTransaction.txn), signedTransaction.txn.freezeState);
                    break;
                }
            }
            // if closeRemainderTo field occur in txParam
            // we will change rekeyTo field to webTx.getFromAddress(txParam)
            if (payFlags.closeRemainderTo) {
                payFlags.rekeyTo = web_1.tx.getTxFromAddress(signedTransaction.txn);
            }
            else {
                payFlags.rekeyTo = web_1.tx.getTxReKeyToToAddress(signedTransaction.txn);
            }
            // apply rekey after pass all logic
            this.rekeyTo(signedTransaction.txn, payFlags.rekeyTo);
            if (this.isInnerTx) {
                // pop current application in the inner app call stack
                this.innerTxAppIDCallStack.pop();
                if (this.innerTxAppIDCallStack.length === 1) {
                    this.runtime.ctx.innerTxAppIDCallStack.pop();
                }
            }
            if (r) {
                txReceipts.push(r);
            }
        });
        return txReceipts;
    }
}
exports.Ctx = Ctx;
//# sourceMappingURL=ctx.js.map