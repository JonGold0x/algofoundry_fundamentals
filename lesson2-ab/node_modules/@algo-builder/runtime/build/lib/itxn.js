"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addInnerTransaction = exports.getInnerTxDefaultFee = exports.calculateInnerTxCredit = exports.setInnerTxField = void 0;
const algosdk_1 = __importStar(require("algosdk"));
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const errors_list_1 = require("../errors/errors-list");
const runtime_errors_1 = require("../errors/runtime-errors");
const constants_1 = require("../lib/constants");
const parsing_1 = require("./parsing");
const txn_1 = require("./txn");
// supported types for inner tx (typeEnum -> type mapping)
// https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/#txn-f
const TxnTypeMap = {
    1: { version: 5, field: "pay" },
    2: { version: 6, field: "keyreg" },
    3: { version: 5, field: "acfg" },
    4: { version: 5, field: "axfer" },
    5: { version: 5, field: "afrz" },
    6: { version: 6, field: "appl" },
};
// requires their type as number
const numberTxnFields = {
    1: new Set(),
    2: new Set(),
    3: new Set(),
    4: new Set(),
    5: new Set([constants_1.TxFieldEnum.Fee, constants_1.TxnRefFields.FreezeAssetFrozen, constants_1.TxnRefFields.ConfigAssetDecimals, constants_1.TxnRefFields.ConfigAssetDefaultFrozen]),
};
numberTxnFields[6] = (0, lodash_clonedeep_1.default)(numberTxnFields[5]);
[constants_1.TxFieldEnum.VoteFirst, constants_1.TxFieldEnum.VoteLast, constants_1.TxFieldEnum.VoteKeyDilution, constants_1.TxFieldEnum.Nonparticipation, constants_1.TxFieldEnum.ApplicationID].forEach((field) => numberTxnFields[6].add(field));
numberTxnFields[7] = (0, lodash_clonedeep_1.default)(numberTxnFields[6]);
numberTxnFields[8] = (0, lodash_clonedeep_1.default)(numberTxnFields[7]);
const uintTxnFields = {
    1: new Set(),
    2: new Set(),
    3: new Set(),
    4: new Set(),
    5: new Set([constants_1.TxFieldEnum.Amount, constants_1.TxFieldEnum.AssetAmount, constants_1.TxFieldEnum.TypeEnum, constants_1.TxnRefFields.ConfigAssetTotal]),
};
uintTxnFields[6] = (0, lodash_clonedeep_1.default)(uintTxnFields[5]);
uintTxnFields[7] = (0, lodash_clonedeep_1.default)(uintTxnFields[6]);
uintTxnFields[8] = (0, lodash_clonedeep_1.default)(uintTxnFields[7]);
// these are also uint values, but require that the asset
// be present in Txn.Assets[] array
const assetIDFields = {
    1: new Set(),
    2: new Set(),
    3: new Set(),
    4: new Set(),
    5: new Set([constants_1.TxFieldEnum.XferAsset, constants_1.TxFieldEnum.FreezeAsset, constants_1.TxFieldEnum.ConfigAsset]),
};
assetIDFields[6] = (0, lodash_clonedeep_1.default)(assetIDFields[5]);
assetIDFields[7] = (0, lodash_clonedeep_1.default)(assetIDFields[6]);
assetIDFields[8] = (0, lodash_clonedeep_1.default)(assetIDFields[7]);
const byteTxnFields = {
    1: new Set(),
    2: new Set(),
    3: new Set(),
    4: new Set(),
    5: new Set([constants_1.TxnRefFields.ConfigAssetMetadataHash]),
};
byteTxnFields[6] = (0, lodash_clonedeep_1.default)(byteTxnFields[5]);
[
    constants_1.TxFieldEnum.VotePK,
    constants_1.TxFieldEnum.SelectionPK,
    constants_1.TxFieldEnum.Note,
    constants_1.TxnaField.ApplicationArgs,
    constants_1.TxFieldEnum.ApprovalProgram,
    constants_1.TxFieldEnum.ClearStateProgram,
].forEach((field) => byteTxnFields[6].add(field));
byteTxnFields[7] = (0, lodash_clonedeep_1.default)(byteTxnFields[6]);
[constants_1.TxnaField.ApprovalProgramPages, constants_1.TxnaField.ClearStateProgramPages].forEach((field) => byteTxnFields[7].add(field));
byteTxnFields[8] = (0, lodash_clonedeep_1.default)(byteTxnFields[7]);
const strTxnFields = {
    1: new Set(),
    2: new Set(),
    3: new Set(),
    4: new Set(),
    5: new Set([constants_1.TxFieldEnum.Type, constants_1.TxnRefFields.ConfigAssetName, constants_1.TxnRefFields.ConfigAssetUnitName, constants_1.TxnRefFields.ConfigAssetURL]),
};
strTxnFields[6] = (0, lodash_clonedeep_1.default)(strTxnFields[5]);
strTxnFields[7] = (0, lodash_clonedeep_1.default)(strTxnFields[6]);
strTxnFields[8] = (0, lodash_clonedeep_1.default)(strTxnFields[7]);
const acfgAddrTxnFields = {
    1: new Set(),
    2: new Set(),
    3: new Set(),
    4: new Set(),
    5: new Set([
        constants_1.TxnRefFields.ConfigAssetManager,
        constants_1.TxnRefFields.ConfigAssetReserve,
        constants_1.TxnRefFields.ConfigAssetFreeze,
        constants_1.TxnRefFields.ConfigAssetClawback,
    ]),
};
acfgAddrTxnFields[6] = (0, lodash_clonedeep_1.default)(acfgAddrTxnFields[5]);
acfgAddrTxnFields[7] = (0, lodash_clonedeep_1.default)(acfgAddrTxnFields[6]);
acfgAddrTxnFields[8] = (0, lodash_clonedeep_1.default)(acfgAddrTxnFields[7]);
const otherAddrTxnFields = {
    5: new Set([
        constants_1.TxFieldEnum.Sender,
        constants_1.TxFieldEnum.Receiver,
        constants_1.TxFieldEnum.CloseRemainderTo,
        constants_1.TxFieldEnum.AssetSender,
        constants_1.TxFieldEnum.AssetCloseTo,
        constants_1.TxFieldEnum.AssetReceiver,
        constants_1.TxnRefFields.FreezeAssetAccount,
    ]),
};
otherAddrTxnFields[6] = (0, lodash_clonedeep_1.default)(otherAddrTxnFields[5]);
// add new inner transaction fields support in teal v6.
[constants_1.TxFieldEnum.RekeyTo].forEach((field) => otherAddrTxnFields[6].add(field));
otherAddrTxnFields[7] = (0, lodash_clonedeep_1.default)(otherAddrTxnFields[6]);
otherAddrTxnFields[8] = (0, lodash_clonedeep_1.default)(otherAddrTxnFields[7]);
const txTypes = {
    1: new Set(),
    2: new Set(),
    3: new Set(),
    4: new Set(),
    5: new Set(["pay", "axfer", "acfg", "afrz"]),
};
// supported keyreg on teal v6
txTypes[6] = (0, lodash_clonedeep_1.default)(txTypes[5]);
txTypes[6].add("keyreg");
txTypes[6].add("appl");
txTypes[7] = (0, lodash_clonedeep_1.default)(txTypes[6]);
txTypes[8] = (0, lodash_clonedeep_1.default)(txTypes[7]);
/**
 * Sets inner transaction field to subTxn (eg. set assetReceiver('rcv'))
 * https://developer.algorand.org/docs/get-details/dapps/smart-contracts/apps/#setting-transaction-properties
 */
/* eslint-disable sonarjs/cognitive-complexity */
function setInnerTxField(subTxn, field, val, op, interpreter, line) {
    let txValue;
    const tealVersion = interpreter.tealVersion;
    if (uintTxnFields[tealVersion].has(field)) {
        txValue = op.assertBigInt(val, line);
    }
    if (numberTxnFields[tealVersion].has(field)) {
        txValue = Number(op.assertBigInt(val, line));
    }
    if (assetIDFields[tealVersion].has(field)) {
        const id = op.assertBigInt(val, line);
        txValue = interpreter.getAssetIDByReference(Number(id), false, line, op);
    }
    if (strTxnFields[tealVersion].has(field)) {
        const assertedVal = op.assertBytes(val, line);
        txValue = (0, parsing_1.convertToString)(assertedVal);
    }
    if (byteTxnFields[tealVersion].has(field)) {
        txValue = op.assertBytes(val, line);
    }
    if (otherAddrTxnFields[tealVersion].has(field)) {
        const assertedVal = op.assertBytes(val, line);
        const accountState = interpreter.getAccount(assertedVal, line);
        txValue = Buffer.from((0, algosdk_1.decodeAddress)(accountState.address).publicKey);
    }
    // if address use for acfg we only check address is valid
    if (acfgAddrTxnFields[tealVersion].has(field)) {
        txValue = op.assertAlgorandAddress(val, line);
    }
    let encodedField = constants_1.TxnFields[tealVersion][field]; // eg 'rcv'
    // txValue can be undefined for a field with not having TEALv5 support (eg. type 'appl')
    if (txValue === undefined) {
        throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.ITXN_FIELD_ERR, {
            msg: `Field ${field} is invalid`,
            field: field,
            line: line,
            tealV: tealVersion,
        });
    }
    // handle individual cases
    let errMsg = "";
    switch (field) {
        case constants_1.TxFieldEnum.Type: {
            const txType = txValue;
            // check if txType is supported in current teal version
            if (!txTypes[tealVersion].has(txType)) {
                errMsg = `${txType} is not a valid Type for itxn_field`;
            }
            break;
        }
        case constants_1.TxFieldEnum.TypeEnum: {
            const txType = op.assertBigInt(val, line);
            if (TxnTypeMap[Number(txType)] === undefined ||
                TxnTypeMap[Number(txType)].version > interpreter.tealVersion) {
                errMsg = `TypeEnum ${Number(txType)}does not support`;
            }
            else {
                subTxn.type = String(TxnTypeMap[Number(txType)].field);
            }
            break;
        }
        case constants_1.TxnRefFields.ConfigAssetDecimals: {
            const assetDecimals = txValue;
            if (assetDecimals > 19n || assetDecimals < 0n) {
                errMsg = "Decimals must be between 0 (non divisible) and 19";
            }
            break;
        }
        case constants_1.TxnRefFields.ConfigAssetMetadataHash: {
            const assetMetadataHash = txValue;
            if (assetMetadataHash.length !== 32) {
                errMsg = "assetMetadataHash must be a 32 byte Uint8Array or string.";
            }
            break;
        }
        case constants_1.TxnRefFields.ConfigAssetUnitName: {
            const assetUnitName = txValue;
            if (assetUnitName.length > 8) {
                errMsg = "Unit name must not be longer than 8 bytes";
            }
            break;
        }
        case constants_1.TxnRefFields.ConfigAssetName: {
            const assetName = txValue;
            if (assetName.length > 32) {
                errMsg = "AssetName must not be longer than 8 bytes";
            }
            break;
        }
        case constants_1.TxnRefFields.ConfigAssetURL: {
            const assetURL = txValue;
            if (assetURL.length > 96) {
                errMsg = "URL must not be longer than 96 bytes";
            }
            break;
        }
        case constants_1.TxFieldEnum.VotePK: {
            const votePk = txValue;
            if (votePk.length !== 32) {
                errMsg = "VoteKey must be 32 bytes";
            }
            break;
        }
        case constants_1.TxFieldEnum.SelectionPK: {
            const selectionPK = txValue;
            if (selectionPK.length !== 32) {
                errMsg = "SelectionPK must be 32 bytes";
            }
            break;
        }
        case constants_1.TxFieldEnum.Note: {
            const note = txValue;
            if (note.length > constants_1.MaxTxnNoteBytes) {
                errMsg = `Note must not be longer than ${constants_1.MaxTxnNoteBytes} bytes`;
            }
            break;
        }
        case constants_1.TxnaField.ApprovalProgramPages: {
            encodedField = "apap";
            const approvalProgram = subTxn[encodedField];
            const maxPossible = constants_1.MaxAppProgramLen * (1 + constants_1.MaxExtraAppProgramPages);
            if (approvalProgram !== undefined) {
                //append
                txValue = new Uint8Array([...approvalProgram, ...txValue]);
            }
            if (txValue.length > maxPossible) {
                errMsg = `Approval Program exceeded the maximum allowed length of ${maxPossible} bytes`;
            }
            break;
        }
        case constants_1.TxnaField.ClearStateProgramPages: {
            encodedField = "apsu";
            const clearStateProgram = subTxn[encodedField];
            const maxPossible = constants_1.MaxAppProgramLen * (1 + constants_1.MaxExtraAppProgramPages);
            if (clearStateProgram !== undefined) {
                //append
                txValue = new Uint8Array([...clearStateProgram, ...txValue]);
            }
            if (txValue.length > maxPossible) {
                errMsg = `Clear State Program exceeded the maximum allowed length of ${maxPossible} bytes`;
            }
            break;
        }
        default: {
            break;
        }
    }
    if (errMsg) {
        throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.ITXN_FIELD_ERR, {
            msg: errMsg,
            field: field,
            line: line,
            tealV: tealVersion,
        });
    }
    // if everything goes well, set the [key, value]
    if (encodedField === null) {
        return subTxn; // could be for TxFieldEnum.TypeEnum
    }
    else if (txn_1.assetTxnFields.has(field)) {
        subTxn.apar = subTxn.apar ?? {};
        subTxn.apar[encodedField] = txValue;
    }
    else {
        if (field === constants_1.TxnRefFields.ApplicationArgs) {
            if (subTxn[encodedField] === undefined) {
                subTxn[encodedField] = [];
            }
            subTxn[encodedField].push(txValue);
        }
        else {
            subTxn[encodedField] = txValue;
        }
    }
    return subTxn;
}
exports.setInnerTxField = setInnerTxField;
/**
 * Calculate remaining fee after executing an inner transaction;
 * @param interpeter current interpeter contain context
 */
function calculateInnerTxCredit(interpeter) {
    // calculate curret txn group fee
    const feeInfo = (0, txn_1.calculateFeeCredit)(interpeter.currentInnerTxnGroup);
    // plus fee from outner
    feeInfo.collectedFee += interpeter.runtime.ctx.remainingFee;
    feeInfo.remainingFee = feeInfo.collectedFee - feeInfo.requiredFee;
    return feeInfo;
}
exports.calculateInnerTxCredit = calculateInnerTxCredit;
// return 0 if transaction pay by pool fee
// return `ALGORAND_MIN_TX_FEE` if transaction pay by contract (pooled not enough fee).
function getInnerTxDefaultFee(interpeter) {
    // sum of outnerCredit.remaining and executedInnerCredit remaining
    const creditFee = calculateInnerTxCredit(interpeter).remainingFee;
    // if remaining fee is enough to pay current tx set default fee to zero
    // else set fee to ALGORAND_MIN_TX_FEE and contract will pay this transaction
    return creditFee >= constants_1.ALGORAND_MIN_TX_FEE ? 0 : constants_1.ALGORAND_MIN_TX_FEE;
}
exports.getInnerTxDefaultFee = getInnerTxDefaultFee;
/**
 * Add new inner tx to inner tx group
 * @param interpreter interpeter execute current tx
 * @param line line number
 * @returns EncTx object
 */
function addInnerTransaction(interpreter, line) {
    // get app, assert it exists
    const appID = interpreter.runtime.ctx.tx.apid ?? 0;
    interpreter.runtime.assertAppDefined(appID, interpreter.getApp(appID, line), line);
    // get application's account
    const address = (0, algosdk_1.getApplicationAddress)(appID);
    const applicationAccount = interpreter.runtime.assertAccountDefined(address, interpreter.runtime.ctx.state.accounts.get(address), line);
    return {
        // set sender, fee, fv, lv
        snd: Buffer.from(algosdk_1.default.decodeAddress(applicationAccount.address).publicKey),
        // user can change this fee
        fee: getInnerTxDefaultFee(interpreter),
        fv: interpreter.runtime.ctx.tx.fv,
        lv: interpreter.runtime.ctx.tx.lv,
        // to avoid type hack
        gen: interpreter.runtime.ctx.tx.gen,
        gh: interpreter.runtime.ctx.tx.gh,
        txID: "",
        type: constants_1.TransactionTypeEnum.UNKNOWN,
    };
}
exports.addInnerTransaction = addInnerTransaction;
//# sourceMappingURL=itxn.js.map