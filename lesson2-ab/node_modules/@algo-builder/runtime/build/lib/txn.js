"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeITxn = exports.calculateFeeCredit = exports.encTxToExecParams = exports.transactionAndSignToExecParams = exports.isEncTxApplicationCall = exports.isEncTxApplicationCreate = exports.isEncTxAssetTransfer = exports.isEncTxAssetOptIn = exports.isEncTxAssetFreeze = exports.isEncTxAssetRevoke = exports.isEncTxAssetReconfigure = exports.isEncTxAssetCreate = exports.isEncTxAssetConfig = exports.isEncTxAssetDeletion = exports.txAppArg = exports.txnSpecByField = exports.checkIfAssetDeletionTx = exports.parseToStackElem = exports.assetTxnFields = void 0;
const web_1 = require("@algo-builder/web");
const algosdk_1 = require("algosdk");
const errors_list_1 = require("../errors/errors-list");
const runtime_errors_1 = require("../errors/runtime-errors");
const constants_1 = require("../lib/constants");
const types_1 = require("../types");
const parsing_1 = require("./parsing");
exports.assetTxnFields = new Set([
    constants_1.TxnRefFields.ConfigAssetTotal,
    constants_1.TxnRefFields.ConfigAssetDecimals,
    constants_1.TxnRefFields.ConfigAssetDefaultFrozen,
    constants_1.TxnRefFields.ConfigAssetUnitName,
    constants_1.TxnRefFields.ConfigAssetName,
    constants_1.TxnRefFields.ConfigAssetURL,
    constants_1.TxnRefFields.ConfigAssetMetadataHash,
    constants_1.TxnRefFields.ConfigAssetManager,
    constants_1.TxnRefFields.ConfigAssetReserve,
    constants_1.TxnRefFields.ConfigAssetFreeze,
    constants_1.TxnRefFields.ConfigAssetClawback,
]);
const globalAndLocalNumTxnFields = new Set([
    constants_1.TxnRefFields.GlobalNumUint,
    constants_1.TxnRefFields.GlobalNumByteSlice,
    constants_1.TxnRefFields.LocalNumUint,
    constants_1.TxnRefFields.LocalNumByteSlice,
]);
// return default value of txField if undefined,
// otherwise return parsed data to interpreter
// checks if byte array size is inbound
function parseToStackElem(a, field) {
    if (typeof a === "number" || typeof a === "bigint" || typeof a === "boolean") {
        return BigInt(a);
    }
    let byteArray = new Uint8Array();
    if (a === undefined) {
        const result = constants_1.TxFieldDefaults[field];
        if (result !== Uint8Array) {
            return result;
        }
        byteArray = result;
    }
    if (a instanceof Uint8Array) {
        byteArray = a;
    }
    if (Buffer.isBuffer(a)) {
        byteArray = new Uint8Array(a);
    }
    if (typeof a === "string") {
        byteArray = web_1.parsing.stringToBytes(a);
    }
    if (byteArray.length > constants_1.maxStringSize) {
        throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.MAX_BYTE_ARRAY_EXCEEDED, {
            maxStringSize: constants_1.maxStringSize,
        });
    }
    if ((field === constants_1.TxFieldEnum.ApprovalProgram || field === constants_1.TxFieldEnum.ClearStateProgram) &&
        byteArray.length > constants_1.MaxAppProgramLen) {
        throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.PROGRAM_LENGTH_EXCEEDED, {
            maxAppProgramLen: constants_1.MaxAppProgramLen,
        });
    }
    return byteArray;
}
exports.parseToStackElem = parseToStackElem;
/**
 * Check if given transaction is asset deletion
 * @param txn EncTx Object
 * Logic:
 * https://developer.algorand.org/docs/reference/transactions/#asset-configuration-transaction
 * https://github.com/algorand/js-algorand-sdk/blob/e07d99a2b6bd91c4c19704f107cfca398aeb9619/src/transaction.ts#L528
 */
function checkIfAssetDeletionTx(txn) {
    return (String(txn.type) === constants_1.TransactionTypeEnum.ASSET_CONFIG && // type should be asset config
        txn.assetIndex > 0 && // assetIndex should not be 0
        !(txn.assetClawback || txn.assetFreeze || txn.assetManager || txn.assetReserve)); // fields should be empty
}
exports.checkIfAssetDeletionTx = checkIfAssetDeletionTx;
/**
 * Description: returns specific transaction field value from tx object
 * @param txField: transaction field
 * @param tx Current transaction
 * @param gtxns Transaction group
 * @param interpreter interpreter object
 */
/* eslint-disable sonarjs/cognitive-complexity */
function txnSpecByField(txField, tx, gtxns, interpreter) {
    let result; // store raw result, parse and return
    const tealVersion = interpreter.tealVersion;
    // handle nested encoded obj (for AssetDef, AppGlobalNumFields, AppLocalNumFields)
    if (exports.assetTxnFields.has(txField)) {
        const s = constants_1.TxnFields[tealVersion][txField];
        const assetMetaData = tx.apar;
        result = assetMetaData?.[s];
        return parseToStackElem(result, txField);
    }
    if (globalAndLocalNumTxnFields.has(txField)) {
        const encAppGlobalSchema = txField.includes(constants_1.TxnRefFields.Global) ? tx.apgs : tx.apls;
        const s = constants_1.TxnFields[tealVersion][txField];
        result = encAppGlobalSchema?.[s];
        return parseToStackElem(result, txField);
    }
    // handle other cases
    switch (txField) {
        case constants_1.TxnRefFields.FirstValidTime: {
            const oneBeforeFirstValid = (tx.fv === undefined ? 0 : tx.fv) - 1;
            interpreter.assertRoundIsAvailable(oneBeforeFirstValid);
            result = interpreter.runtime.getBlock(oneBeforeFirstValid).timestamp;
            break;
        }
        case constants_1.TxFieldEnum.TypeEnum: {
            result = Number(types_1.TxnType[tx.type]); // TxnType['pay']
            break;
        }
        case constants_1.TxnRefFields.TxID: {
            return web_1.parsing.stringToBytes(tx.txID);
        }
        case constants_1.TxnRefFields.GroupIndex: {
            result = gtxns.indexOf(tx);
            break;
        }
        case constants_1.TxnRefFields.NumAppArgs: {
            const appArg = constants_1.TxnFields[tealVersion].ApplicationArgs;
            const appArgs = tx[appArg];
            result = appArgs?.length;
            break;
        }
        case constants_1.TxnRefFields.NumAccounts: {
            const appAcc = constants_1.TxnFields[tealVersion].Accounts;
            const appAccounts = tx[appAcc];
            result = appAccounts?.length;
            break;
        }
        case constants_1.TxnRefFields.NumAssets: {
            const encAppAsset = constants_1.TxnFields[tealVersion].Assets; // 'apas'
            const foreignAssetsArr = tx[encAppAsset];
            result = foreignAssetsArr?.length;
            break;
        }
        case constants_1.TxnRefFields.NumApplications: {
            const encApp = constants_1.TxnFields[tealVersion].Applications; // 'apfa'
            const foreignAppsArr = tx[encApp];
            result = foreignAppsArr?.length;
            break;
        }
        case constants_1.TxFieldEnum.AssetSender: {
            // if tx.asns is undefined we return zero address;
            if (tx.type === "axfer") {
                result = tx.asnd ?? Buffer.from(constants_1.ZERO_ADDRESS);
            }
            break;
        }
        case constants_1.TxnRefFields.CreatedAssetID: {
            const asaInfo = interpreter.runtime.ctx.state.txReceipts.get(tx.txID);
            if (asaInfo !== undefined)
                result = BigInt(asaInfo.assetIndex);
            else
                result = 0n;
            break;
        }
        case constants_1.TxnRefFields.CreatedApplicationID: {
            const appInfo = interpreter.runtime.ctx.state.txReceipts.get(tx.txID);
            if (appInfo.appID !== undefined)
                result = BigInt(appInfo.appID);
            else if (isEncTxApplicationCreate(tx))
                result = BigInt(interpreter.runtime.ctx.state.appCounter + 1);
            else
                result = 0n;
            break;
        }
        case constants_1.TxFieldEnum.LastLog: {
            result = interpreter.runtime.ctx.lastLog;
            break;
        }
        case constants_1.TxFieldEnum.StateProofPK: {
            // While running teal debugger, TxFieldEnum.StateProofPK always return 64 zero bytes.
            // so we set up 64 zero bytes as default value of StateProofPK
            result = new Uint8Array(64).fill(0); // 64 zero bytes
            break;
        }
        case constants_1.TxnRefFields.NumApprovalProgramPages: {
            tx.apap ? (result = Math.ceil(tx.apap.length / constants_1.maxStringSize)) : (result = 0n);
            break;
        }
        case constants_1.TxnRefFields.NumClearStateProgramPages: {
            tx.apsu ? (result = Math.ceil(tx.apsu.length / constants_1.maxStringSize)) : (result = 0n);
            break;
        }
        default: {
            const s = constants_1.TxnFields[tealVersion][txField]; // eg: rcv = TxnFields[TxFieldEnum.Receiver]
            result = tx[s]; // pk_buffer = tx['rcv']
        }
    }
    return parseToStackElem(result, txField);
}
exports.txnSpecByField = txnSpecByField;
/**
 * Returns specific transaction field value from array
 * of accounts or application args
 * @param tx current transaction
 * @param txField transaction field
 * @param idx index in EncodedTransaction[txField]
 * @param op Op object
 * @param interpreter interpreter object
 * @param line line number in TEAL file
 */
/* eslint-disable sonarjs/cognitive-complexity */
function txAppArg(txField, tx, idx, op, interpreter, line) {
    const tealVersion = interpreter.tealVersion;
    if (txField === constants_1.TxnaField.Logs) {
        const txReceipt = interpreter.runtime.ctx.state.txReceipts.get(tx.txID);
        const logs = txReceipt?.logs ?? [];
        op.checkIndexBound(idx, logs, op.line);
        return parseToStackElem(logs[idx], txField);
    }
    else if (txField === constants_1.TxnaField.ApprovalProgramPages && tx.apap) {
        const pageCount = Math.ceil(tx.apap.length / constants_1.maxStringSize);
        if (idx > pageCount) {
            throw new Error("invalid ApprovalProgramPages page index");
        }
        const first = idx * constants_1.maxStringSize;
        const last = Math.min(first + constants_1.maxStringSize, tx.apap.length);
        const page = tx.apap.slice(first, last);
        return parseToStackElem(page, txField);
    }
    else if (txField === constants_1.TxnRefFields.NumApprovalProgramPages && tx.apap) {
        const pageCount = Math.ceil(tx.apap.length / constants_1.maxStringSize);
        return parseToStackElem(pageCount, txField);
    }
    else if (txField === constants_1.TxnaField.ClearStateProgramPages && tx.apsu) {
        const pageCount = Math.ceil(tx.apsu.length / constants_1.maxStringSize);
        if (idx > pageCount) {
            throw new Error("invalid ClearStateProgramPages page index");
        }
        const first = idx * constants_1.maxStringSize;
        const last = Math.min(first + constants_1.maxStringSize, tx.apsu.length);
        const page = tx.apsu.slice(first, last);
        return parseToStackElem(page, txField);
    }
    else if (txField === constants_1.TxnRefFields.NumClearStateProgramPages && tx.apsu) {
        const pageCount = Math.ceil(tx.apsu.length / constants_1.maxStringSize);
        return parseToStackElem(pageCount, txField);
    }
    const s = constants_1.TxnFields[tealVersion][txField]; // 'apaa' or 'apat'
    const result = tx[s]; // array of pk buffers (accounts or appArgs)
    if (!result) {
        // handle defaults
        return constants_1.TxFieldDefaults[txField];
    }
    /**
     * handle special case of accounts and applications:
     * + EncTx.Accounts[0] represents sender's account
     * + EncTx.Applications[0] represents current_application_id
     * https://pyteal.readthedocs.io/en/stable/accessing_transaction_field.html#special-case-txn-accounts-and-txn-applications
     */
    if (txField === constants_1.TxnaField.Accounts) {
        if (idx === 0) {
            return parseToStackElem(tx.snd, txField);
        }
        idx--; // if not sender, then reduce index by 1
    }
    else if (txField === constants_1.TxnaField.Applications) {
        if (idx === 0) {
            return parseToStackElem(tx.apid ?? 0n, txField);
        } // during ssc deploy tx.app_id is 0
        idx--;
    }
    op.checkIndexBound(idx, result, line);
    return parseToStackElem(result[idx], txField);
}
exports.txAppArg = txAppArg;
/**
 * Check if given encoded transaction obj is asset deletion
 * @param txn Encoded EncTx Object
 * Logic:
 * https://developer.algorand.org/docs/reference/transactions/#asset-configuration-transaction
 * https://github.com/algorand/js-algorand-sdk/blob/e07d99a2b6bd91c4c19704f107cfca398aeb9619/src/transaction.ts#L528
 */
function isEncTxAssetDeletion(txn) {
    return (txn.type === constants_1.TransactionTypeEnum.ASSET_CONFIG && // type should be asset config
        txn.caid !== undefined &&
        txn.caid !== 0 && // assetIndex should not be 0
        !(txn.apar?.m ?? txn.apar?.r ?? txn.apar?.f ?? txn.apar?.c)); // fields should be empty
}
exports.isEncTxAssetDeletion = isEncTxAssetDeletion;
/**
 * Check if given encoded transaction obj is asset config
 * @param txn Encoded EncTx Object
 */
function isEncTxAssetConfig(txn) {
    return (txn.type === constants_1.TransactionTypeEnum.ASSET_CONFIG && // type should be asset config
        txn.caid !== undefined &&
        txn.caid !== 0 && // assetIndex should not be 0
        !isEncTxAssetDeletion(txn) // AND should not be asset deletion
    );
}
exports.isEncTxAssetConfig = isEncTxAssetConfig;
/**
 * Check if given encoded transaction obj is asset creation
 * @param txn Encoded EncTx Object
 */
function isEncTxAssetCreate(txn) {
    return (txn.type === constants_1.TransactionTypeEnum.ASSET_CONFIG && // type should be asset config
        txn.caid === undefined && // assetIndex should be undefined
        txn.apar !== undefined // assetParameters should not be undefined
    );
}
exports.isEncTxAssetCreate = isEncTxAssetCreate;
/**
 * Checks if given encoded transaction obj is asset reconfiguration
 * @param txn Encoded EncTx Object
 */
function isEncTxAssetReconfigure(txn) {
    return (txn.type === constants_1.TransactionTypeEnum.ASSET_CONFIG && // type should be asset config
        txn.caid !== undefined && // assetIndex should be undefined
        txn.apar !== undefined && // assetParameters should not be undefined
        (txn.apar.m !== undefined || // manager
            txn.apar.f !== undefined || // freeze
            txn.apar.c !== undefined || // clawback
            txn.apar.r !== undefined) // reserve
    );
}
exports.isEncTxAssetReconfigure = isEncTxAssetReconfigure;
/**
 * Checks if given encoded transaction obj is asset revoke
 * @param txn Encoded EncTx Object
 */
function isEncTxAssetRevoke(txn) {
    return txn.asnd !== undefined;
}
exports.isEncTxAssetRevoke = isEncTxAssetRevoke;
/**
 * Checks if given encoded transaction obj is asset freeze
 * @param txn Encoded EncTx Object
 */
function isEncTxAssetFreeze(txn) {
    return txn.afrz !== undefined && txn.fadd !== undefined;
}
exports.isEncTxAssetFreeze = isEncTxAssetFreeze;
/**
 * Checks if given encoded transaction obj is asset opt in
 * @param txn Encoded EncTx Object
 */
function isEncTxAssetOptIn(txn) {
    if (txn.arcv !== undefined) {
        return !txn.arcv.compare(txn.snd);
    }
    else {
        return false;
    }
}
exports.isEncTxAssetOptIn = isEncTxAssetOptIn;
/**
 * Checks if given encoded transaction obj is asset opt in
 * @param txn Encoded EncTx Object
 */
function isEncTxAssetTransfer(txn) {
    return txn.arcv !== undefined && txn.snd !== undefined && txn.asnd === undefined;
}
exports.isEncTxAssetTransfer = isEncTxAssetTransfer;
/**
 * Check if given encoded transaction object is app creation
 * @param txn Encoded EncTx Object
 */
function isEncTxApplicationCreate(txn) {
    return (txn.type === constants_1.TransactionTypeEnum.APPLICATION_CALL &&
        (txn.apan === 0 || txn.apan === undefined) &&
        txn.apid === undefined);
}
exports.isEncTxApplicationCreate = isEncTxApplicationCreate;
/**
 * Check if given encoded transaction object is application call
 * @param txn Encode EncTx Object
 */
function isEncTxApplicationCall(txn) {
    return txn.type === constants_1.TransactionTypeEnum.APPLICATION_CALL && txn.apid !== undefined;
}
exports.isEncTxApplicationCall = isEncTxApplicationCall;
/**
 *
 * @param txAndSign transaction and sign
 * @param ctx context which is tx and sign apply
 * @returns ExecParams object equivalent with txAndSign
 */
function transactionAndSignToExecParams(txAndSign, ctx) {
    const transaction = txAndSign.transaction;
    const encTx = transaction.get_obj_for_encoding();
    // inject approval Program and clear program with string format.
    // TODO: should create function to convert TEAL in Uint8Array to string format?
    encTx.approvalProgram = transaction.approvalProgram;
    encTx.clearProgram = transaction.clearProgram;
    const sign = txAndSign.sign;
    return encTxToExecParams(encTx, sign, ctx);
}
exports.transactionAndSignToExecParams = transactionAndSignToExecParams;
/* eslint-disable sonarjs/cognitive-complexity */
function encTxToExecParams(encTx, sign, ctx, line) {
    const execParams = {
        ...sign,
        payFlags: {},
    };
    execParams.payFlags.totalFee = encTx.fee;
    if (ArrayBuffer.isView(encTx.type)) {
        encTx.type = Buffer.from(encTx.type).toString("utf-8");
    }
    switch (encTx.type) {
        case constants_1.TransactionTypeEnum.APPLICATION_CALL: {
            if (isEncTxApplicationCreate(encTx)) {
                const appDefinition = {
                    appName: "Mock",
                    metaType: web_1.types.MetaType.FILE,
                    approvalProgramFilename: encTx.approvalProgram,
                    clearProgramFilename: encTx.clearProgram,
                    localInts: encTx.apls?.nui,
                    localBytes: encTx.apls?.nbs,
                    globalInts: encTx.apgs?.nui,
                    globalBytes: encTx.apgs?.nbs,
                };
                execParams.type = web_1.types.TransactionType.DeployApp;
                execParams.appDefinition = appDefinition;
            }
            else if (isEncTxApplicationCall(encTx)) {
                execParams.type = web_1.types.TransactionType.CallApp;
                execParams.appID = encTx.apid;
                execParams.appArgs = encTx.apaa;
            }
            break;
        }
        case constants_1.TransactionTypeEnum.PAYMENT: {
            execParams.type = web_1.types.TransactionType.TransferAlgo;
            execParams.fromAccountAddr = _getAddress(encTx.snd);
            execParams.toAccountAddr =
                getRuntimeAccountAddr(encTx.rcv, ctx, line) ?? constants_1.ZERO_ADDRESS_STR;
            execParams.amountMicroAlgos = encTx.amt ? BigInt(encTx.amt) : 0n;
            if (encTx.close) {
                execParams.payFlags.closeRemainderTo = getRuntimeAccountAddr(encTx.close, ctx, line);
            }
            if (encTx.rekey) {
                execParams.payFlags.rekeyTo = _getAddress(encTx.rekey);
            }
            break;
        }
        case constants_1.TransactionTypeEnum.ASSET_FREEZE: {
            execParams.type = web_1.types.TransactionType.FreezeAsset;
            execParams.assetID = encTx.faid;
            execParams.freezeTarget = getRuntimeAccountAddr(encTx.fadd, ctx, line);
            execParams.freezeState = BigInt(encTx.afrz ?? 0n) === 1n;
            if (encTx.rekey) {
                execParams.payFlags.rekeyTo = _getAddress(encTx.rekey);
            }
            break;
        }
        case constants_1.TransactionTypeEnum.ASSET_TRANSFER: {
            if (encTx.asnd !== undefined) {
                // if 'AssetSender' is set, it is clawback transaction
                execParams.type = web_1.types.TransactionType.RevokeAsset;
                execParams.recipient = getRuntimeAccountAddr(encTx.arcv, ctx, line) ?? constants_1.ZERO_ADDRESS_STR;
                execParams.revocationTarget = getRuntimeAccountAddr(encTx.asnd, ctx, line);
            }
            else {
                // asset transfer
                execParams.type = web_1.types.TransactionType.TransferAsset;
                execParams.toAccountAddr = getRuntimeAccountAddr(encTx.arcv, ctx) ?? constants_1.ZERO_ADDRESS_STR;
            }
            // set common fields (asset amount, index, closeRemainderTo)
            execParams.amount = encTx.aamt ? BigInt(encTx.aamt) : 0n;
            execParams.assetID = encTx.xaid ?? 0;
            // option fields
            if (encTx.aclose) {
                execParams.payFlags.closeRemainderTo = getRuntimeAccountAddr(encTx.aclose, ctx, line);
            }
            if (encTx.rekey) {
                execParams.payFlags.rekeyTo = _getAddress(encTx.rekey);
            }
            break;
        }
        case constants_1.TransactionTypeEnum.ASSET_CONFIG: {
            if (isEncTxAssetDeletion(encTx)) {
                execParams.type = web_1.types.TransactionType.DestroyAsset;
                execParams.assetID = encTx.caid;
            }
            else if (isEncTxAssetConfig(encTx)) {
                // from the docs: all fields must be reset, otherwise they will be cleared
                // https://developer.algorand.org/docs/get-details/dapps/smart-contracts/apps/#asset-configuration
                execParams.type = web_1.types.TransactionType.ModifyAsset;
                execParams.assetID = encTx.caid;
                execParams.fields = {
                    manager: _getASAConfigAddr(encTx.apar?.m),
                    reserve: _getASAConfigAddr(encTx.apar?.r),
                    clawback: _getASAConfigAddr(encTx.apar?.c),
                    freeze: _getASAConfigAddr(encTx.apar?.f),
                };
            }
            else {
                // if not delete or modify, it's ASA deployment
                execParams.type = web_1.types.TransactionType.DeployASA;
                execParams.asaName = encTx.apar?.an;
                execParams.asaDef = {
                    name: encTx.apar?.an,
                    total: Number(encTx.apar?.t),
                    decimals: encTx.apar?.dc !== undefined ? Number(encTx.apar.dc) : 0,
                    defaultFrozen: BigInt(encTx.apar?.df ?? 0n) === 1n,
                    unitName: encTx.apar?.un,
                    url: encTx.apar?.au,
                    metadataHash: encTx.apar?.am ? (0, parsing_1.convertToString)(encTx.apar?.am) : undefined,
                    manager: _getASAConfigAddr(encTx.apar?.m),
                    reserve: _getASAConfigAddr(encTx.apar?.r),
                    clawback: _getASAConfigAddr(encTx.apar?.c),
                    freeze: _getASAConfigAddr(encTx.apar?.f),
                };
            }
            break;
        }
        case constants_1.TransactionTypeEnum.KEY_REGISTRATION: {
            execParams.type = web_1.types.TransactionType.KeyRegistration;
            // execParams.voteKey = encTx.votekey?.toString("base64");
            if (encTx.votekey !== undefined) {
                execParams.voteKey = Buffer.from(encTx.votekey).toString("base64");
            }
            // execParams.selectionKey = encTx.selkey?.toString("base64");
            if (encTx.selkey !== undefined) {
                execParams.selectionKey = Buffer.from(encTx.selkey).toString("base64");
            }
            execParams.voteFirst = encTx.votefst;
            execParams.voteLast = encTx.votelst;
            execParams.voteKeyDilution = encTx.votekd;
            break;
        }
        default: {
            // if line is defined => called from ItxnSubmit
            // => throw error with itxn_submit
            if (line) {
                throw new Error(`unsupported type for itxn_submit at line ${line}`);
            }
            else {
                throw new Error("Can't convert encode tx to execParams");
            }
        }
    }
    return execParams;
}
exports.encTxToExecParams = encTxToExecParams;
const _getASAConfigAddr = (addr) => {
    if (addr) {
        return (0, algosdk_1.encodeAddress)(addr);
    }
    return "";
};
const getRuntimeAccount = (publicKey, ctx, line) => {
    if (publicKey === undefined) {
        return undefined;
    }
    const address = (0, algosdk_1.encodeAddress)(Uint8Array.from(publicKey));
    const runtimeAcc = ctx.getAccount(address);
    return runtimeAcc.account;
};
const getRuntimeAccountAddr = (publickey, ctx, line) => {
    return getRuntimeAccount(publickey, ctx, line)?.addr;
};
const _getAddress = (addr) => {
    if (addr) {
        return (0, algosdk_1.encodeAddress)(addr);
    }
    return undefined;
};
/**
 *
 * @param groupTx group transaction
 * @returns remainingFee - fee remaining after execute group Tx
 * 			collected fee - fee collected from group Tx
 * 			required fee - fee require to execute group tx
 */
function calculateFeeCredit(groupTx) {
    let collectedFee = 0;
    for (const tx of groupTx) {
        collectedFee += tx.fee ?? 0;
    }
    const requiredFee = groupTx.length * constants_1.ALGORAND_MIN_TX_FEE;
    return {
        remainingFee: collectedFee - requiredFee,
        collectedFee,
        requiredFee,
    };
}
exports.calculateFeeCredit = calculateFeeCredit;
/**
 * Retunrs field f of the last inner transaction
 * @param op ITxna or ITxn opcode
 * @returns result
 */
function executeITxn(op) {
    const groupTx = op.interpreter.innerTxnGroups[op.interpreter.innerTxnGroups.length - 1];
    const tx = groupTx[groupTx.length - 1];
    let result;
    switch (op.field) {
        case constants_1.TxnaField.Logs: {
            const txReceipt = op.interpreter.runtime.ctx.state.txReceipts.get(tx.txID);
            const logs = txReceipt?.logs ?? [];
            op.checkIndexBound(op.idx, logs, op.line);
            result = logs[op.idx];
            break;
        }
        case constants_1.TxnRefFields.NumLogs: {
            const txReceipt = op.interpreter.runtime.ctx.state.txReceipts.get(tx.txID);
            const logs = txReceipt?.logs ?? [];
            result = BigInt(logs.length);
            break;
        }
        default: {
            result = txnSpecByField(op.field, tx, [tx], op.interpreter);
            if (result === undefined || Object(result).length === 0) {
                result = txAppArg(op.field, tx, op.idx, op, op.interpreter, op.line);
                break;
            }
        }
    }
    return result;
}
exports.executeITxn = executeITxn;
//# sourceMappingURL=txn.js.map