import { types } from "@algo-builder/web";
import algosdk, { Account as AccountSDK, modelsv2, SignedTransaction, Transaction } from "algosdk";
import { AccountStore } from "./account";
import { LogicSigAccount } from "./logicsig";
import { AccountAddress, AccountStoreI, AppInfo, AppOptionalFlags, ASADeploymentFlags, ASAInfo, AssetHoldingM, Block, Context, EncTx, ExecutionMode, RuntimeAccountI, SCParams, SSCAttributesM, StackElem, TxnReceipt, TxReceipt } from "./types";
export declare class Runtime {
    /**
     * We are using Maps instead of algosdk arrays
     * because of faster and easy querying.
     * This way when querying, instead of traversing the whole object,
     * we can get the value directly from Map
     * Note: Runtime operates on `store`, it doesn't operate on `ctx`.
     */
    private store;
    private _defaultAccounts;
    ctx: Context;
    parentCtx?: Context;
    loadedAssetsDefs: types.ASADefs;
    private round;
    private timestamp;
    private readonly numberOfInitialBlocks;
    constructor(accounts: AccountStoreI[]);
    get defaultBalance(): number;
    /**
     * Returns a list of initialized default accounts created using static accountSDK from account.ts
     *  and funded with default balance (100 ALGO)
     * @returns list of AccountStore
     */
    _setupDefaultAccounts(): AccountStore[];
    /**
     * Resets the state of the default accounts
     */
    resetDefaultAccounts(): void;
    /**
     * Getter for _defaultAccounts, returns a synced version of the accounts list
     * @returns list of AccountStore
     */
    defaultAccounts(): AccountStore[];
    /**
     * Returns transaction receipt for a particular transaction
     * @param txID transaction ID
     */
    getTxReceipt(txID: string): TxReceipt | undefined;
    /**
     * asserts if account is defined.
     * @param address address
     * @param a account
     * @param line line number in TEAL file
     * Note: if user is accessing this function directly through runtime,
     * the line number is unknown
     */
    assertAccountDefined(address: string, a?: AccountStoreI, line?: number): AccountStoreI;
    /**
     * asserts if account address is defined
     * @param addr account address
     * @param line line number in TEAL file
     * Note: if user is accessing this function directly through runtime,
     * the line number is unknown
     */
    assertAddressDefined(addr: string | undefined, line?: number): string;
    /**
     * asserts if application exists in state
     * @param app application
     * @param appID application index
     * @param line line number in TEAL file
     * Note: if user is accessing this function directly through runtime,
     * the line number is unknown
     */
    assertAppDefined(appID: number, app?: SSCAttributesM, line?: number): SSCAttributesM;
    /**
     * asserts if asset exists in state
     * @param assetId asset index
     * @param assetDef asset definitions
     * @param line line number
     * Note: if user is accessing this function directly through runtime,
     * the line number is unknown
     */
    assertAssetDefined(assetId: number, assetDef?: modelsv2.AssetParams, line?: number): modelsv2.AssetParams;
    /**
     * Validate first and last rounds of transaction using current round
     * @param gtxns transactions
     */
    validateTxRound(gtxns: EncTx[]): void;
    /**
     * Ensure no duplicate transaction in group txn
     * @param gtxns group transaction
     */
    assertNoDuplicateTransaction(gtxns: EncTx[]): void;
    /**
     * set current round with timestamp for a block
     * @param r current round
     * @param timestamp block's timestamp
     */
    setRoundAndTimestamp(r: number, timestamp: number): void;
    /**
     * Return current round
     */
    getRound(): number;
    /**
     * Return current timestamp
     */
    getTimestamp(): number;
    /**
     * Fetches app from `this.store`
     * @param appID Application Index
     */
    getApp(appID: number): SSCAttributesM;
    /**
     * Fetches account from `this.store`
     * @param address account address
     */
    getAccount(address: string): AccountStoreI;
    /**
     * Fetches global state value for key present in creator's global state
     * for given appID, returns undefined otherwise
     * @param appID: current application id
     * @param key: key to fetch value of from local state
     */
    getGlobalState(appID: number, key: Uint8Array | string): StackElem | undefined;
    /**
     * Fetches local state for account address and application index
     * @param appID application index
     * @param accountAddr address for which local state needs to be retrieved
     * @param key: key to fetch value of from local state
     */
    getLocalState(appID: number, accountAddr: string, key: Uint8Array | string): StackElem | undefined;
    /**
     * Returns asset creator account or throws error is it doesn't exist
     * @param assetId Index
     */
    getAssetAccount(assetId: number): AccountStoreI;
    /**
     * Returns Asset Definitions
     * @param assetId Asset Index
     */
    getAssetDef(assetId: number): modelsv2.AssetParams;
    /**
     * Queries asset id by asset name from global state.
     * Returns undefined if asset is not found.
     * @param name Asset name
     */
    getAssetInfoFromName(name: string): ASAInfo | undefined;
    /**
     * Queries app id by app name from global state.
     * Returns undefined if app is not found.
     * https://www.pivotaltracker.com/story/show/180142720
     * @param approval
     * @param clear
     */
    getAppInfoFromName(approval: string, clear: string): AppInfo | undefined;
    /**
     * Queries app id by app name from global state.
     * Returns undefined if app is not found.
     * @param appName
     */
    getAppByName(appName: string): AppInfo | undefined;
    /**
     * Setup initial accounts as {address: SDKAccount}. This should be called only when initializing Runtime.
     * @param accounts: array of account info's
     */
    initializeAccounts(accounts: AccountStoreI[]): void;
    /**
     * Add accounts from config file to the Store
     * @param network: the network of accounts to add
     * @param balance: balance for accounts
     */
    loadAccountsFromConfig(network?: string, balance?: number): void;
    /**
     * Creates new transaction object (tx, gtxs) from given txnParams and signes it
     * @param txnParams : Transaction parameters for current txn or txn Group
     * @returns: [current SignedTransaction, SignedTransaction group]
     */
    createTxnContext(txnParams: types.ExecParams[]): [SignedTransaction, SignedTransaction[]];
    /**
     * Creates new asset creation transaction object.
     * @param name : asset name
     * @param flags: asa deployment flags
     * @param asaDef: asa definition
     */
    mkAssetCreateTx(name: string, flags: ASADeploymentFlags, asaDef: modelsv2.AssetParams): void;
    /**
     * Deploy Asset in Runtime using asa.yaml
     * @param asa ASA name
     * @param flags ASA Deployment Flags
     */
    deployASA(asa: string, flags: ASADeploymentFlags): ASAInfo;
    /**
     * Deploy Asset in Runtime without using asa.yaml
     * @param asa ASA name
     * @param flags ASA Deployment Flags
     */
    deployASADef(asa: string, asaDef: types.ASADef, flags: ASADeploymentFlags): ASAInfo;
    /**
     * Opt-In to all accounts given in asa.yaml to a specific asset.
     * @param assetID Asset Index
     * @param accounts list account opt to asa
     */
    optInToASAMultiple(assetID: number, accounts?: string[]): void;
    /**
     * Asset Opt-In for account in Runtime
     * @param assetIndex Asset Index
     * @param address Account address to opt-into asset
     * @param flags Transaction Parameters
     */
    optInToASA(assetIndex: number, address: AccountAddress, flags: types.TxParams): TxReceipt;
    /**
     * Returns Asset Holding from an account
     * @param assetIndex Asset Index
     * @param address address of account to get holding from
     */
    getAssetHolding(assetIndex: number, address: AccountAddress): AssetHoldingM;
    addCtxAppCreateTxn(creator: AccountSDK, appDef: types.AppDefinition, payFlags: types.TxParams): void;
    /**
     * deploy a new application and returns application id
     * @param payFlags Transaction parameters
     * @param appDefinition app definition
     * @param scTmplParams Smart Contract template parameters
     * @param debugStack: if passed then TEAL Stack is logged to console after
     * each opcode execution (upto depth = debugStack)
     */
    deployApp(sender: AccountSDK, appDefinition: types.AppDefinition, payFlags: types.TxParams, scTmplParams?: SCParams, debugStack?: number): AppInfo;
    addCtxOptInTx(senderAddr: string, appID: number, payFlags: types.TxParams, flags: AppOptionalFlags): void;
    /**
     * Account address opt-in for application Id
     * @param accountAddr Account address
     * @param appID Application Id
     * @param flags Stateful smart contract transaction optional parameters (accounts, args..)
     * @param payFlags Transaction Parameters
     * @param debugStack: if passed then TEAL Stack is logged to console after
     * each opcode execution (upto depth = debugStack)
     */
    optInToApp(accountAddr: string, appID: number, flags: AppOptionalFlags, payFlags: types.TxParams, debugStack?: number): TxReceipt;
    addCtxAppUpdateTx(senderAddr: string, appID: number, payFlags: types.TxParams, flags: AppOptionalFlags): void;
    /**
     * Update application
     * @param appName application Name. Note in runtime application name just placeholder params
     * @param senderAddr sender address
     * @param appID application Id
     * @param newAppCode new application source code
     * @param payFlags Transaction parameters
     * @param flags Stateful smart contract transaction optional parameters (accounts, args..)
     * @param debugStack: if passed then TEAL Stack is logged to console after
     * each opcode execution (upto depth = debugStack)
     */
    updateApp(appName: string, senderAddr: string, appID: number, newAppCode: types.SmartContract, payFlags: types.TxParams, flags: AppOptionalFlags, scTmplParams?: SCParams, debugStack?: number): TxReceipt;
    assertMinBalance(amt: bigint, address: string): void;
    /**
     * Validate signature for Algorand account on transaction params.
     * Include check spending account when creating a transaction from Algorand account
     * Throw RuntimeError if signature is invalid.
     * @param txParam transaction parameters.
     */
    validateAccountSignature(txParam: types.ExecParams): void;
    /**
     * Loads logic signature for contract mode, creates a new runtime account
     * associated with lsig
     * @param fileName ASC filename
     * @param scTmplParams: Smart contract template parameters (used only when compiling PyTEAL to TEAL)
     * @param logs only show logs on console when set as true. By default this value is true
     * @returns loaded logic signature from assets/<file_name>.teal
     */
    loadLogic(fileName: string, scTmplParams?: SCParams, logs?: boolean): LogicSigAccount;
    /**
     * Creates a new account with logic signature and smart contract arguments
     * in the runtime store. The arguments are used when we send a transaction with this
     * account and verify it.
     * @param program TEAL code
     * @param args arguments passed
     * @returns logic signature with arguments.
     */
    createLsigAccount(program: string, args: Uint8Array[]): LogicSigAccount;
    /**
     * Transfers `amount` of microAlgos from `from` address to `to` address
     * @param from From account
     * @param to to address
     * @param amount amount of algo in microalgos
     */
    fundLsig(from: RuntimeAccountI, to: AccountAddress, amount: number): TxnReceipt;
    /**
     * validate logic signature and teal logic
     * @param txnParam Transaction Parameters
     * @param debugStack: if passed then TEAL Stack is logged to console after
     * each opcode execution (upto depth = debugStack)
     */
    validateLsigAndRun(txnParam: types.Lsig, debugStack?: number): TxReceipt;
    /**
     * This function executes a transaction based on a smart contract logic and updates state afterwards
     * Check out {@link https://algobuilder.dev/guide/execute-transaction.html#execute-transaction|execute-transaction}
     * for more info.
     * @param txnParams : Transaction parameters
     * @param debugStack: if passed then TEAL Stack is logged to console after
     * each opcode execution (upto depth = debugStack)
     */
    executeTx(txnParams: types.ExecParams[] | algosdk.SignedTransaction[], debugStack?: number): TxnReceipt[];
    /**
     * This function executes TEAL code line by line
     * @param program : teal code as string
     * @param executionMode : execution Mode (Stateless or Stateful)
     * @param indexInGroup: txn index in transaction group.
     * @param debugStack: if passed then TEAL Stack is logged to console after
     * each opcode execution (upto depth = debugStack)
     * NOTE: Application mode is only supported in TEALv > 1
     */
    run(program: string, executionMode: ExecutionMode, indexInGroup: number, debugStack?: number): TxReceipt;
    /**
     * Creates a group transaction array
     * @param signedTransactions : teal code as string
     * @returns groupTransactions array of EncTx type
     */
    getEncodedGroupTxns(signedTransactions: SignedTransaction[]): EncTx[];
    /**
     * Sends a SignedTransaction object
     * @param signedTransaction
     * @returns const txReceipts = this.ctx.processTransactions(signedTransactions, appDefMap, lsigMap);
     */
    sendSignedTransaction(signedTransaction: SignedTransaction): TxReceipt[];
    /**
     * Validate signature for Algorand account on transaction params.
     * Include check spending account when creating a transaction from Algorand account
     * Throw RuntimeError if signature is invalid.
     * @param signedTransaction signedTransaction object.
     */
    validateSecretKeySignature(signedTransaction: SignedTransaction): void;
    /**
     * Verifies multi-signature and throws an error if signatures are not valid
     * @param signedTransaction signedTransaction object
     */
    validateMultisignature(signedTransaction: algosdk.SignedTransaction): void;
    /**
     * Verifies extra pages do not exceed the limit
     * @param extraPages extra pages for program. Default value is 0
     */
    validateExtraPages(extraPages?: number): void;
    /**
     * Verify multi-signature
     * @param signedTxn signedTransaction object
     */
    verifyMultisig(signedTxn: SignedTransaction): boolean;
    /** Creates an algosdk.Transaction object based on execParams and suggestedParams
     * @param execParams execParams containing all txn info
     * @param txParams suggestedParams object
     * @returns array of algosdk.Transaction objects
     */
    makeTx(execParams: types.ExecParams[], txParams: algosdk.SuggestedParams): Transaction[];
    /**
     * Signes a Transaction object with the provided account
     * @param transaction transaction object.
     * @param signer account object that signes the transaction
     * @returns SignedTransaction
     */
    signTx(transaction: algosdk.Transaction, signer: AccountSDK): SignedTransaction;
    /**
     * Creates an algosdk.Transaction object based on execParams and suggestedParams
     * and signs it using provided signer account
     * @param execParams execParams containing all txn info
     * @param txParams suggestedParams object
     * @param signer account object that signes the transaction
     * @returns array of algosdk.SignedTransaction objects
     */
    makeAndSignTx(execParams: types.ExecParams[], txParams: algosdk.SuggestedParams, signer: AccountSDK): SignedTransaction[];
    /**
     * Sends signedTransaction and waits for the response
     * @param transactions array of signedTransaction objects.
     * @returns TxnReceipt which includes confirmed txn response along with txID
     */
    sendTxAndWait(transactions: SignedTransaction[]): TxnReceipt[];
    /**
     * Parses the file and return the ABIContract. If the appID for runtime
     * is specified it will be added to the returned object
     * @param pathToFile string
     * @retun parsed file
     */
    parseABIContractFile(pathToFile: string): types.ABIContract;
    /**
     * Produces new block and adds it to a Map where the keys are block numbers
     */
    private _produceBlock;
    /**
     * Returns a requested Block object. If it does not exist on chain throws an error
     * @param round block number
     * @returns Block
     */
    getBlock(round: number): Block;
    /**
     * Produces N new blocks. If not arguments passed N = 1 by default
     * @param numberOfBlocks current round number
     */
    produceBlocks(numberOfBlocks?: number): void;
}
