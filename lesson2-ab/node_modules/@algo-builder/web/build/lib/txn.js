"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mkMultisigEncodedTx = exports.getAssetReconfigureFields = exports.mkTransaction = exports.updateTxFee = exports.getTxFlags = exports.getTxASADefinition = exports.getTxFreezeAddress = exports.getTxReKeyToToAddress = exports.getTxCloseReminderToAddress = exports.getTxToAddress = exports.getAddress = exports.getTxFromAddress = exports.getTxRevokeAddress = exports.getFromAddress = exports.decodeText = exports.encodeNote = void 0;
const algosdk_1 = __importStar(require("algosdk"));
const errors_1 = require("../errors/errors");
const errors_list_1 = require("../errors/errors-list");
const types_1 = require("../types");
const parsing_1 = require("./parsing");
/**
 * Encodes note to bytes
 * When `note` is provided then uses the TexEncoder to convert note to bytes.
 * When `noteb64` is provided then uses base64 decoder to convert base64 text to bytes.
 * Throws an error if both `note` and `noteb64` are provided.
 * */
function encodeNote(note, noteb64) {
    if (note === undefined && noteb64 === undefined) {
        return undefined;
    }
    if (noteb64 && note) {
        throw new errors_1.BuilderError(errors_list_1.ERRORS.ARGUMENTS.INVALID_TX_PARAM, {
            param: "note",
            error: "You can't define both note and noteb64 transaction option",
        });
    }
    if (noteb64) {
        return Buffer.from(noteb64, "base64");
    }
    if (note instanceof Uint8Array)
        return note;
    const encoder = new TextEncoder();
    return encoder.encode(note);
}
exports.encodeNote = encodeNote;
function decodeText(bytes) {
    if (bytes === undefined)
        return undefined;
    return new TextDecoder().decode(bytes);
}
exports.decodeText = decodeText;
/**
 * Returns from address from the transaction params depending on @SignType
 * @param execParams transaction execution params passed by user
 */
function getFromAddress(execParams) {
    if (execParams.sign === types_1.SignType.SecretKey) {
        return execParams.fromAccountAddr || execParams.fromAccount.addr; // eslint-disable-line @typescript-eslint/prefer-nullish-coalescing
    }
    return execParams.fromAccountAddr;
}
exports.getFromAddress = getFromAddress;
/**
 * Returns revocation targer address from the Transaction object
 * @param transaction Transaction Object
 */
function getTxRevokeAddress(transaction) {
    if (transaction.assetRevocationTarget !== undefined) {
        return algosdk_1.default.encodeAddress(transaction.assetRevocationTarget.publicKey);
    }
    else {
        return "CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ";
    }
}
exports.getTxRevokeAddress = getTxRevokeAddress;
/**
 * Returns from address from the Transaction object
 * @param transaction Transaction Object
 */
function getTxFromAddress(transaction) {
    return algosdk_1.default.encodeAddress(transaction.from.publicKey);
}
exports.getTxFromAddress = getTxFromAddress;
function getAddress(account) {
    if (account !== undefined) {
        return algosdk_1.default.encodeAddress(account.publicKey);
    }
    else {
        return undefined;
    }
}
exports.getAddress = getAddress;
/**
 * Returns to address from the Transaction object
 * @param transaction Transaction Object
 */
function getTxToAddress(transaction) {
    return algosdk_1.default.encodeAddress(transaction.to.publicKey);
}
exports.getTxToAddress = getTxToAddress;
/**
 * Returns to address from the Transaction object
 * @param transaction Transaction Object
 */
function getTxCloseReminderToAddress(transaction) {
    if (transaction.closeRemainderTo !== undefined) {
        return algosdk_1.default.encodeAddress(transaction.closeRemainderTo.publicKey);
    }
    else {
        return undefined;
    }
}
exports.getTxCloseReminderToAddress = getTxCloseReminderToAddress;
/**
 * Returns  reKeyTo address of the Transaction object
 * @param transaction Transaction Object
 */
function getTxReKeyToToAddress(transaction) {
    if (transaction.reKeyTo !== undefined) {
        return algosdk_1.default.encodeAddress(transaction.reKeyTo.publicKey);
    }
    else {
        return undefined;
    }
}
exports.getTxReKeyToToAddress = getTxReKeyToToAddress;
/**
 * Returns freeze target address of the Transaction object
 * @param transaction Transaction Object
 */
function getTxFreezeAddress(transaction) {
    if (transaction.freezeAccount !== undefined) {
        return algosdk_1.default.encodeAddress(transaction.freezeAccount.publicKey);
    }
    else {
        return "CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ";
    }
}
exports.getTxFreezeAddress = getTxFreezeAddress;
/**
 * Returns ASA definiton
 * @param transaction Transaction Object
 */
function getTxASADefinition(transaction) {
    const asaDef = {
        clawback: getAddress(transaction.assetClawback),
        manager: getAddress(transaction.assetManager),
        reserve: getAddress(transaction.assetReserve),
        freeze: getAddress(transaction.assetFreeze),
        name: transaction.assetName,
        total: transaction.assetTotal,
        decimals: transaction.assetDecimals,
        defaultFrozen: transaction.assetDefaultFrozen,
        unitName: transaction.assetUnitName,
        url: transaction.assetURL,
        metadataHash: transaction.assetMetadataHash
            ? new TextDecoder().decode(transaction.assetMetadataHash)
            : undefined,
        note: undefined,
    };
    return asaDef;
}
exports.getTxASADefinition = getTxASADefinition;
/**
 * Returns to address from the Transaction object
 * @param transaction Transaction Object
 */
function getTxFlags(transaction) {
    const transactionFlags = {};
    transactionFlags.closeRemainderTo = getTxCloseReminderToAddress(transaction);
    transactionFlags.lease = transaction.lease;
    transactionFlags.note = decodeText(transaction.note);
    transactionFlags.rekeyTo = getTxReKeyToToAddress(transaction);
    transactionFlags.firstValid = transaction.firstRound;
    transactionFlags.validRounds = transaction.lastRound - transaction.firstRound;
    if (transaction.flatFee === true) {
        transactionFlags.totalFee = transaction.fee;
        transactionFlags.flatFee = true;
    }
    else {
        transactionFlags.feePerByte = transaction.fee;
    }
    return transactionFlags;
}
exports.getTxFlags = getTxFlags;
/**
 * Using flatFee, if flatFee is true, set totalFee
 * https://developer.algorand.org/tutorials/setting-transaction-fee-javascript/
 * @param params Transaction parameters
 * @param tx SDK Transaction object
 */
function updateTxFee(params, tx) {
    if (params.totalFee !== undefined) {
        tx.fee = params.totalFee;
    }
    return tx;
}
exports.updateTxFee = updateTxFee;
/**
 * Converts ExecParams to Algo SDK Transaction.
 * ExecParams is a type safe and more friendly way to create Algorand transactions.
 *  + AlgoTransferParam used for transferring algo
 *  + AssetTransferParam used for transferring asset
 *  + ModifyAssetParam used to modify asset mutable properties
 *  + FreezeAssetParam used to freeze asset (only permitted by asa freeze account)
 *  + RevokeAssetParam used to revoke assets (by asset clawback)
 *  + DestroyAssetParam used to delete asset (by asset manager)
 *  + Deploy Params - deploy ASA, deploy App
 *  + OptIn Params - optInToASA, optInToApp
 *  + AppCallsParam (NoOp, Clear, Delete..)used for calling stateful smart contracts.
 For more advanced use-cases, please use `algosdk.tx` directly.
 NOTE: parseAppArgs is used to handle case when user passes appArgs similar to goal
 * @param execParams ExecParams
 * @param suggestedParams blockchain transaction suggested parameters (firstRound, lastRound, fee..)
 * @returns SDK Transaction object
 */
/* eslint-disable sonarjs/cognitive-complexity */
function mkTransaction(execParams, suggestedParams) {
    const note = encodeNote(execParams.payFlags.note, execParams.payFlags.noteb64);
    const transactionType = execParams.type;
    const fromAccountAddr = getFromAddress(execParams);
    switch (execParams.type) {
        case types_1.TransactionType.TransferAsset: {
            const tx = algosdk_1.default.makeAssetTransferTxnWithSuggestedParams(fromAccountAddr, execParams.toAccountAddr, execParams.payFlags.closeRemainderTo, undefined, execParams.amount, note, execParams.assetID, suggestedParams, execParams.payFlags.rekeyTo);
            return updateTxFee(execParams.payFlags, tx);
        }
        case types_1.TransactionType.ModifyAsset: {
            const tx = algosdk_1.default.makeAssetConfigTxnWithSuggestedParams(fromAccountAddr, note, execParams.assetID, execParams.fields.manager !== "" ? execParams.fields.manager : undefined, execParams.fields.reserve !== "" ? execParams.fields.reserve : undefined, execParams.fields.freeze !== "" ? execParams.fields.freeze : undefined, execParams.fields.clawback !== "" ? execParams.fields.clawback : undefined, suggestedParams, false, execParams.payFlags.rekeyTo);
            return updateTxFee(execParams.payFlags, tx);
        }
        case types_1.TransactionType.FreezeAsset: {
            const tx = algosdk_1.default.makeAssetFreezeTxnWithSuggestedParams(fromAccountAddr, note, execParams.assetID, execParams.freezeTarget, execParams.freezeState, suggestedParams, execParams.payFlags.rekeyTo);
            return updateTxFee(execParams.payFlags, tx);
        }
        case types_1.TransactionType.RevokeAsset: {
            const tx = algosdk_1.default.makeAssetTransferTxnWithSuggestedParams(fromAccountAddr, execParams.recipient, execParams.payFlags.closeRemainderTo, execParams.revocationTarget, execParams.amount, note, execParams.assetID, suggestedParams, execParams.payFlags.rekeyTo);
            return updateTxFee(execParams.payFlags, tx);
        }
        case types_1.TransactionType.DestroyAsset: {
            const tx = algosdk_1.default.makeAssetDestroyTxnWithSuggestedParams(fromAccountAddr, note, execParams.assetID, suggestedParams, execParams.payFlags.rekeyTo);
            return updateTxFee(execParams.payFlags, tx);
        }
        case types_1.TransactionType.TransferAlgo: {
            const tx = algosdk_1.default.makePaymentTxnWithSuggestedParams(fromAccountAddr, execParams.toAccountAddr, execParams.amountMicroAlgos, execParams.payFlags.closeRemainderTo, note, suggestedParams, execParams.payFlags.rekeyTo);
            return updateTxFee(execParams.payFlags, tx);
        }
        case types_1.TransactionType.ClearApp: {
            const tx = algosdk_1.default.makeApplicationClearStateTxn(fromAccountAddr, suggestedParams, execParams.appID, (0, parsing_1.parseAppArgs)(execParams.appArgs), execParams.accounts, execParams.foreignApps, execParams.foreignAssets, note, execParams.lease, execParams.payFlags.rekeyTo);
            return updateTxFee(execParams.payFlags, tx);
        }
        case types_1.TransactionType.DeleteApp: {
            const tx = algosdk_1.default.makeApplicationDeleteTxn(fromAccountAddr, suggestedParams, execParams.appID, (0, parsing_1.parseAppArgs)(execParams.appArgs), execParams.accounts, execParams.foreignApps, execParams.foreignAssets, note, execParams.lease, execParams.payFlags.rekeyTo);
            return updateTxFee(execParams.payFlags, tx);
        }
        case types_1.TransactionType.CallApp: {
            const tx = algosdk_1.default.makeApplicationNoOpTxn(fromAccountAddr, suggestedParams, execParams.appID, (0, parsing_1.parseAppArgs)(execParams.appArgs), execParams.accounts, execParams.foreignApps, execParams.foreignAssets, note, execParams.lease, execParams.payFlags.rekeyTo);
            return updateTxFee(execParams.payFlags, tx);
        }
        case types_1.TransactionType.CloseApp: {
            const tx = algosdk_1.default.makeApplicationCloseOutTxn(fromAccountAddr, suggestedParams, execParams.appID, (0, parsing_1.parseAppArgs)(execParams.appArgs), execParams.accounts, execParams.foreignApps, execParams.foreignAssets, note, execParams.lease, execParams.payFlags.rekeyTo);
            return updateTxFee(execParams.payFlags, tx);
        }
        case types_1.TransactionType.DeployASA: {
            if (execParams.asaDef) {
                // https://github.com/algorand/docs/blob/master/examples/assets/v2/javascript/AssetExample.js#L104
                const tx = algosdk_1.default.makeAssetCreateTxnWithSuggestedParams(fromAccountAddr, note, BigInt(execParams.asaDef.total || 0), // eslint-disable-line @typescript-eslint/prefer-nullish-coalescing
                execParams.asaDef.decimals, execParams.asaDef.defaultFrozen ? execParams.asaDef.defaultFrozen : false, execParams.asaDef.manager !== "" ? execParams.asaDef.manager : undefined, execParams.asaDef.reserve !== "" ? execParams.asaDef.reserve : undefined, execParams.asaDef.freeze !== "" ? execParams.asaDef.freeze : undefined, execParams.asaDef.clawback !== "" ? execParams.asaDef.clawback : undefined, execParams.asaDef.unitName, execParams.asaName, execParams.asaDef.url, execParams.asaDef.metadataHash, suggestedParams, execParams.payFlags.rekeyTo);
                return updateTxFee(execParams.payFlags, tx);
            }
            else {
                throw new errors_1.BuilderError(errors_list_1.ERRORS.GENERAL.PARAM_PARSE_ERROR, {
                    reason: "ASA Definition not found",
                    source: execParams.asaName,
                });
            }
        }
        case types_1.TransactionType.DeployApp: {
            const onComplete = algosdk_1.default.OnApplicationComplete.NoOpOC;
            const appDef = execParams.appDefinition;
            if (appDef.metaType === types_1.MetaType.BYTES) {
                const tx = algosdk_1.default.makeApplicationCreateTxn(fromAccountAddr, suggestedParams, onComplete, appDef.approvalProgramBytes, appDef.clearProgramBytes, appDef.localInts, appDef.localBytes, appDef.globalInts, appDef.globalBytes, (0, parsing_1.parseAppArgs)(appDef.appArgs), appDef.accounts, appDef.foreignApps, appDef.foreignAssets, note, appDef.lease, execParams.payFlags.rekeyTo, appDef.extraPages);
                return updateTxFee(execParams.payFlags, tx);
            }
            else {
                // we can't compile a source code nor access local files (as we do in algob) in the web mode.
                throw new Error("Only MetaType.BYTES is supported for deploying apps in the web mode. Provided mode: " +
                    appDef.metaType);
            }
        }
        case types_1.TransactionType.UpdateApp: {
            if (execParams.newAppCode.metaType === types_1.MetaType.BYTES) {
                const tx = algosdk_1.default.makeApplicationUpdateTxn(fromAccountAddr, suggestedParams, execParams.appID, execParams.newAppCode.approvalProgramBytes, execParams.newAppCode.clearProgramBytes, (0, parsing_1.parseAppArgs)(execParams.appArgs), execParams.accounts, execParams.foreignApps, execParams.foreignAssets, note, execParams.lease, execParams.payFlags.rekeyTo);
                return updateTxFee(execParams.payFlags, tx);
            }
            else {
                // we can't compile a source code nor access local files (as we do in algob) in the web mode.
                throw new Error("Only MetaType.BYTES is supported for deploying apps in the web mode. Provided mode: " +
                    execParams.newAppCode.metaType);
            }
        }
        case types_1.TransactionType.OptInToApp: {
            const tx = algosdk_1.default.makeApplicationOptInTxn(fromAccountAddr, suggestedParams, execParams.appID, (0, parsing_1.parseAppArgs)(execParams.appArgs), execParams.accounts, execParams.foreignApps, execParams.foreignAssets, note, execParams.lease, execParams.payFlags.rekeyTo);
            return updateTxFee(execParams.payFlags, tx);
        }
        case types_1.TransactionType.OptInASA: {
            const tx = algosdk_1.default.makeAssetTransferTxnWithSuggestedParams(fromAccountAddr, fromAccountAddr, undefined, undefined, 0, note, execParams.assetID, suggestedParams, execParams.payFlags.rekeyTo);
            return updateTxFee(execParams.payFlags, tx);
        }
        case types_1.TransactionType.KeyRegistration: {
            const tx = algosdk_1.default.makeKeyRegistrationTxnWithSuggestedParams(fromAccountAddr, note, execParams.voteKey, execParams.selectionKey, execParams.voteFirst, execParams.voteLast, execParams.voteKeyDilution, suggestedParams, execParams.payFlags.rekeyTo, execParams.nonParticipation);
            return updateTxFee(execParams.payFlags, tx);
        }
        default: {
            throw new errors_1.BuilderError(errors_list_1.ERRORS.GENERAL.TRANSACTION_TYPE_ERROR, {
                transaction: transactionType,
            });
        }
    }
}
exports.mkTransaction = mkTransaction;
/**
 * Returns the fields necessary for an Asset Modification
 * @param transaction Transaction Object
 */
function getAssetReconfigureFields(transaction) {
    const modificationFields = {};
    const encodedTransaction = transaction.get_obj_for_encoding();
    if (encodedTransaction.apar !== undefined) {
        modificationFields.clawback =
            encodedTransaction.apar.c !== undefined
                ? algosdk_1.default.encodeAddress(transaction.assetClawback.publicKey)
                : "";
        modificationFields.freeze =
            encodedTransaction.apar.f !== undefined
                ? algosdk_1.default.encodeAddress(transaction.assetFreeze.publicKey)
                : "";
        modificationFields.manager =
            encodedTransaction.apar.m !== undefined
                ? algosdk_1.default.encodeAddress(transaction.assetManager.publicKey)
                : "";
        modificationFields.reserve =
            encodedTransaction.apar.r !== undefined
                ? algosdk_1.default.encodeAddress(transaction.assetReserve.publicKey)
                : "";
    }
    return modificationFields;
}
exports.getAssetReconfigureFields = getAssetReconfigureFields;
/**
 * A function to construct a Multisig Encoded Transaction object, which is ready to be signed (internally
 * using the Algorand SDK or a wallet)
 **/
function mkMultisigEncodedTx(mparams, tx) {
    const subsig = [];
    for (const address of mparams.addrs) {
        subsig.push({ pk: (0, algosdk_1.decodeAddress)(address).publicKey });
    }
    return {
        msig: { v: mparams.version, thr: mparams.threshold, subsig: subsig },
        txn: tx.get_obj_for_encoding(),
    };
}
exports.mkMultisigEncodedTx = mkMultisigEncodedTx;
//# sourceMappingURL=txn.js.map