"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MyAlgoWalletSession = void 0;
const algosdk_1 = __importDefault(require("algosdk"));
const __1 = require("..");
const types_1 = require("../types");
const api_1 = require("./api");
const constants_1 = require("./constants");
const logger_1 = require("./logger");
const txn_1 = require("./txn");
class MyAlgoWalletSession {
    constructor(walletURL, connector) {
        this.accounts = [];
        this.addresses = [];
        this.algodClient = (0, api_1.algoexplorerAlgod)(walletURL);
        try {
            const MyAlgoConnect = require("@randlabs/myalgo-connect"); // eslint-disable-line @typescript-eslint/no-var-requires
            if (connector) {
                this.connector = connector;
            }
            else {
                this.connector = new MyAlgoConnect();
            }
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * @async
     * @description Signs a teal program (https://algorand.github.io/js-algorand-sdk/modules.html#tealSign)
     * @param logic Teal program
     * @param address Signer Address
     * @returns Returns signed teal
     * for more info: https://connect.myalgo.com/docs/interactive-examples/TealSign
     * https://developer.algorand.org/docs/get-details/dapps/smart-contracts/smartsigs/modes/#delegated-approval
     */
    async signLogic(logic, address) {
        try {
            return await this.connector.signLogicSig(logic, address);
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw new Error("Error while signing teal program" + err);
        }
    }
    /**
     * @description Takes a transaction and a LogicSig object and returns an encoded signed transaction.
     * @param transaction algosdk.Transaction object
     * @param logicSig Logic Sig Account
     * @returns Returns txID and blob object
     * for more info: https://developer.algorand.org/docs/get-details/dapps/smart-contracts/smartsigs/modes/#contract-account
     */
    signLogicSigTx(transaction, logicSig) {
        try {
            return algosdk_1.default.signLogicSigTransaction(transaction, logicSig);
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * @async
     * @description Connects to the MyAlgo Wallet by opening up its dialog box to login
     * @param allowMultipleAccounts allow selection of multiple accounts from MyAlgo Wallet, default is true
     * For Multisig you need to allow multiple accounts login
     * for more info visit: https://connect.myalgo.com/docs/interactive-examples/Connect
     */
    async connectToMyAlgo(allowMultipleAccounts = true) {
        try {
            this.accounts = await this.connector.connect({
                shouldSelectOneAccount: !allowMultipleAccounts,
                openManager: true,
            });
            this.addresses = this.accounts.map((account) => account.address);
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw new Error("Error while connecting to MyAlgo Wallet" + err);
        }
    }
    /**
     * https://connect.myalgo.com/docs/interactive-examples/PaymentTransaction
     * Sign a single transaction from a my algo wallet session
     * @param txn { SDK transaction object, shouldSign, signers, msig } object
     * @returns raw signed txn
     */
    async signTransaction(txn, signOptions) {
        try {
            return await this.connector.signTransaction(txn.toByte(), signOptions);
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * https://connect.myalgo.com/docs/interactive-examples/GroupedTransaction
     * Sign a group of transaction(s) from a my algo wallet session
     * @param txns { SDK transaction object, shouldSign, signers, msig } object
     * @returns array of raw signed txns | null. null representes that the txn in array is NOT signed
     * by wallet user (i.e signable by someone else).
     */
    async signTransactionGroup(txns, signOptions) {
        try {
            const txnsGroup = txns.map((v) => v.txn);
            const groupID = algosdk_1.default.computeGroupID(txnsGroup);
            for (let i = 0; i < txns.length; i++) {
                // called from executeTx where groupID is already assigned
                if (!txnsGroup[i].group) {
                    txnsGroup[i].group = groupID;
                }
            }
            return await this.connector.signTransaction(txnsGroup.map((txn) => txn.toByte()), signOptions);
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Send signed transaction to network and wait for confirmation
     * @param rawTxns Signed Transaction(s)
     * @param waitRounds number of rounds to wait for transaction to be confirmed - default is 10
     * @returns TxnReceipt which includes confirmed txn response along with txID
     */
    async sendAndWait(rawTxns, waitRounds = constants_1.WAIT_ROUNDS) {
        try {
            const txInfo = await this.algodClient.sendRawTransaction(rawTxns).do();
            return await this.waitForConfirmation(txInfo.txId, waitRounds);
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Function used to wait for a tx confirmation
     * @param txId txn ID for which confirmation is required
     * @param waitRounds number of rounds to wait for transaction to be confirmed - default is 10
     * @returns TxnReceipt which includes confirmed txn response along with txID
     */
    async waitForConfirmation(txId, waitRounds = constants_1.WAIT_ROUNDS) {
        try {
            const pendingInfo = await algosdk_1.default.waitForConfirmation(this.algodClient, txId, waitRounds);
            if (pendingInfo["pool-error"]) {
                throw new Error(`Transaction Pool Error: ${pendingInfo["pool-error"]}`);
            }
            const txnReceipt = { txID: txId, ...pendingInfo };
            return txnReceipt;
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Execute single transaction or group of transactions (atomic transaction)
     * @param execParams transaction parameters or atomic transaction parameters
     */
    async executeTx(execParams) {
        try {
            let signedTxn;
            let txns = [];
            if (execParams.length > 16) {
                throw new Error("Maximum size of an atomic transfer group is 16");
            }
            if ((0, types_1.isSDKTransactionAndSign)(execParams[0]))
                throw new Error("We don't support this case now");
            for (const [_, txn] of execParams.entries()) {
                txns.push((0, txn_1.mkTransaction)(txn, await (0, __1.mkTxParams)(this.algodClient, txn.payFlags)));
            }
            txns = algosdk_1.default.assignGroupID(txns);
            // with logic signature we set shouldSign to false
            const toBeSignedTxns = execParams.map((txn, index) => {
                return txn.sign === types_1.SignType.LogicSignature
                    ? { txn: txns[index], shouldSign: false } // logic signature
                    : { txn: txns[index], shouldSign: true }; // to be signed
            });
            // only shouldSign txn are to be signed, algowallet doesn't accept lsig ones
            const nonLsigTxn = toBeSignedTxns.filter((txn) => txn.shouldSign);
            if (nonLsigTxn.length) {
                signedTxn = await this.signTransactionGroup(nonLsigTxn);
            }
            // sign smart signature transaction
            for (const [index, txn] of txns.entries()) {
                const signer = execParams[index];
                if (signer.sign === types_1.SignType.LogicSignature) {
                    signer.lsig.lsig.args = signer.args ? signer.args : [];
                    if (!Array.isArray(signedTxn))
                        signedTxn = [];
                    signedTxn.splice(index, 0, this.signLogicSigTx(txn, signer.lsig));
                }
            }
            signedTxn = signedTxn?.filter((stxn) => stxn);
            const Uint8ArraySignedTx = signedTxn?.map((stxn) => stxn.blob);
            const confirmedTx = await this.sendAndWait(Uint8ArraySignedTx);
            (0, logger_1.log)("confirmedTx: ", confirmedTx);
            return confirmedTx;
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Creates an algosdk.Transaction object based on execParams and suggestedParams
     * @param execParams execParams containing all txn info
     * @param txParams suggestedParams object
     * @returns array of algosdk.Transaction objects
     */
    makeTx(execParams, txParams) {
        try {
            const txns = [];
            for (const [_, txn] of execParams.entries()) {
                txns.push((0, txn_1.mkTransaction)(txn, txParams));
            }
            return txns;
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Signs a Transaction object with with myAlgoWallet
     * @param transaction transaction object.
     * @returns SignedTransaction
     */
    async signTx(transaction) {
        try {
            const signedTx = await this.connector.signTransaction(transaction.toByte());
            const blob = signedTx.blob;
            return algosdk_1.default.decodeSignedTransaction(blob);
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Creates an algosdk.Transaction object based on execParams and suggestedParams
     * and signs with myAlgoWallet
     * @param execParams execParams containing all txn info
     * @param txParams suggestedParams object
     * @returns array of algosdk.SignedTransaction objects
     */
    async makeAndSignTx(execParams, txParams) {
        try {
            const signedTxns = [];
            const txns = this.makeTx(execParams, txParams);
            for (const transaction of txns) {
                const signedTransaction = await this.signTx(transaction);
                signedTxns.push(signedTransaction);
            }
            return signedTxns;
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Sends signedTransaction and waits for the response
     * @param transactions array of signedTransaction objects.
     * @param rounds number of rounds to wait for response
     * @returns TxnReceipt which includes confirmed txn response along with txID
     */
    async sendTxAndWait(transactions, rounds) {
        try {
            if (transactions.length < 1) {
                throw new Error("No transactions to process");
            }
            else {
                const Uint8ArraySignedTx = transactions.map((txn) => algosdk_1.default.encodeObj(txn));
                return await this.sendAndWait(Uint8ArraySignedTx, rounds);
            }
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
}
exports.MyAlgoWalletSession = MyAlgoWalletSession;
//# sourceMappingURL=myalgowallet-mode.js.map