"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WallectConnectSession = void 0;
const utils_1 = require("@json-rpc-tools/utils");
const client_1 = __importDefault(require("@walletconnect/client"));
const algorand_walletconnect_qrcode_modal_1 = __importDefault(require("algorand-walletconnect-qrcode-modal"));
const algosdk_1 = __importDefault(require("algosdk"));
const types_1 = require("../types");
const api_1 = require("./api");
const constants_1 = require("./constants");
const logger_1 = require("./logger");
const txn_1 = require("./txn");
class WallectConnectSession {
    constructor(walletURL, connector) {
        this.algodClient = (0, api_1.algoexplorerAlgod)(walletURL);
        if (connector) {
            this.connector = connector;
        }
        else {
            // create new session
            this.connector = new client_1.default({
                bridge: "https://bridge.walletconnect.org",
                qrcodeModal: algorand_walletconnect_qrcode_modal_1.default,
            });
        }
        // if connection not already established, log message to create one
        if (!this.connector.connected) {
            (0, logger_1.warn)(`Connection not established, please use "this.create()" to create new session`);
        }
        this.wcAccounts = this.connector.accounts;
    }
    /**
     * Create new session
     * @param force if true, kills an existing session and creates new one.
     * By default force is false
     */
    async create(force = false) {
        if (this.connector.connected) {
            if (force) {
                try {
                    await this.close();
                }
                catch (e) {
                    (0, logger_1.error)("Can't close walletconnect connection", e);
                    throw e;
                }
            }
            else {
                (0, logger_1.warn)(`A session is already active`);
                return;
            }
        }
        await this.connector.createSession();
    }
    /**
     * Close Connection
     */
    async close() {
        try {
            await this.connector.killSession();
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * On connect subscription event
     * @param handler handler callback
     */
    onConnect(handler) {
        try {
            this.connector.on("connect", (err, payload) => {
                const { peerId, peerMeta, accounts } = payload.params[0];
                this.wcAccounts = accounts;
                handler(err, { peerId, peerMeta, accounts });
            });
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * onUpdate subscription event
     * @param handler handler callback
     */
    onUpdate(handler) {
        try {
            this.connector.on("session_update", (err, payload) => {
                const { accounts } = payload.params[0];
                this.wcAccounts = accounts;
                handler(err, { accounts });
            });
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * onDisconnect subscription event
     * @param handler handler callback
     */
    onDisconnect(handler) {
        try {
            this.connector.on("disconnect", (err, payload) => {
                const { message } = payload.params[0];
                handler(err, { message });
            });
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Sign a single transaction from a wallect connect session
     * @param txn { SDK transaction object, shouldSign, signers, msig } object
     * @param message optional message with txn
     * @returns raw signed txn
     */
    async signTransaction(txn, message) {
        try {
            const txnInGroup = {
                txn,
                shouldSign: true,
                signers: txn.from,
            };
            const response = await this.signTransactionGroup([txnInGroup], message);
            if (response[0] == null) {
                throw new Error("Transaction was returned unsigned");
            }
            return response[0];
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * @description Signs a Logic Signature transaction
     * @param transaction algosdk.Transaction object
     * @param logicSig Logic Sig Account
     * @returns Returns txID and blob object
     * for more info: https://developer.algorand.org/docs/get-details/dapps/smart-contracts/smartsigs/modes/#contract-account
     */
    signLogicSigTx(transaction, logicSig) {
        try {
            return algosdk_1.default.signLogicSigTransaction(transaction, logicSig);
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Sign a group of transaction(s) from a wallect connect session
     * @param txns Array of [{  SDK transaction object, shouldSign, signers, msig }] object
     * @param message optional message with txn
     * @returns array of raw signed txns | null. null representes that the txn in array is NOT signed
     * by wallet user (i.e signable by someone else).
     * TODO: handle case of multiple signers in group transaction
     */
    async signTransactionGroup(txns, message) {
        try {
            const walletTxns = txns.map((txn) => {
                const encodedTxn = Buffer.from(algosdk_1.default.encodeUnsignedTransaction(txn.txn)).toString("base64");
                let signers;
                if (txn.shouldSign) {
                    if (Array.isArray(txn.signers)) {
                        signers = txn.signers;
                    }
                    else if (txn.signers) {
                        signers = [txn.signers];
                    }
                    else {
                        signers = undefined;
                    }
                }
                else {
                    signers = undefined;
                }
                return {
                    signers,
                    txn: encodedTxn,
                    message: txn.message,
                    msig: txn.msig,
                };
            });
            const requestParams = [walletTxns];
            (0, logger_1.log)("requestParams ", requestParams);
            if (message) {
                requestParams.push({ message });
            }
            const request = (0, utils_1.formatJsonRpcRequest)(constants_1.ALGORAND_SIGN_TRANSACTION_REQUEST, requestParams);
            const result = await this.connector.sendCustomRequest(request);
            return result.map((element) => {
                return element ? new Uint8Array(Buffer.from(element, "base64")) : null;
            });
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Send signed transaction to network and wait for confirmation
     * @param rawTxns Signed Transaction(s)
     * @param waitRounds number of rounds to wait for transaction to be confirmed - default is 10
     * @returns TxnReceipt which includes confirmed txn response along with txID
     */
    async sendAndWait(rawTxns, waitRounds = constants_1.WAIT_ROUNDS) {
        try {
            const txInfo = await this.algodClient.sendRawTransaction(rawTxns).do();
            return await this.waitForConfirmation(txInfo.txId, waitRounds);
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Function used to wait for a tx confirmation
     * @param txId txn ID for which confirmation is required
     * @param waitRounds number of rounds to wait for transaction to be confirmed - default is 10
     * @returns TxnReceipt which includes confirmed txn response along with txID
     */
    async waitForConfirmation(txId, waitRounds = constants_1.WAIT_ROUNDS) {
        try {
            const pendingInfo = await algosdk_1.default.waitForConfirmation(this.algodClient, txId, waitRounds);
            if (pendingInfo["pool-error"]) {
                throw new Error(`Transaction Pool Error: ${pendingInfo["pool-error"]}`);
            }
            const txnReceipt = { txID: txId, ...pendingInfo };
            return txnReceipt;
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Execute single transaction or group of transactions (atomic transaction)
     * @param transactions transaction parameters,  atomic transaction parameters
     *  or TransactionAndSign object(SDK transaction object and signer parameters)
     */
    /* eslint-disable sonarjs/cognitive-complexity */
    async executeTx(transactions) {
        try {
            let signedTxn;
            let txns = [];
            if (transactions.length > 16) {
                throw new Error("Maximum size of an atomic transfer group is 16");
            }
            if ((0, types_1.isSDKTransactionAndSign)(transactions[0])) {
                throw new Error("We don't support this case now");
            }
            const execParams = transactions;
            for (const [_, txn] of execParams.entries()) {
                txns.push((0, txn_1.mkTransaction)(txn, await (0, api_1.mkTxParams)(this.algodClient, txn.payFlags)));
            }
            txns = algosdk_1.default.assignGroupID(txns);
            // with logic signature we set shouldSign to false
            const toBeSignedTxns = execParams.map((txn, index) => {
                return txn.sign === types_1.SignType.LogicSignature
                    ? { txn: txns[index], shouldSign: false } // logic signature
                    : {
                        txn: txns[index],
                        shouldSign: true,
                        signers: execParams[index].fromAccount?.addr || execParams[index].fromAccountAddr,
                    }; // to be signed
            });
            // only shouldSign txn are to be signed
            const nonLsigTxn = toBeSignedTxns.filter((txn) => txn.shouldSign);
            if (nonLsigTxn.length > 0) {
                signedTxn = await this.signTransactionGroup(toBeSignedTxns);
            }
            // sign smart signature transaction
            for (const [index, txn] of txns.entries()) {
                const signer = execParams[index];
                if (signer.sign === types_1.SignType.LogicSignature) {
                    signer.lsig.lsig.args = signer.args ? signer.args : [];
                    if (!Array.isArray(signedTxn))
                        signedTxn = [];
                    signedTxn.splice(index, 0, this.signLogicSigTx(txn, signer.lsig).blob);
                }
            }
            // remove null values from signed txns array
            // TODO: replace null values with "externally" signed txns, otherwise
            // signedtxns with nulls will always fail!
            signedTxn = signedTxn?.filter((stxn) => stxn);
            const confirmedTx = await this.sendAndWait(signedTxn);
            (0, logger_1.log)("confirmedTx: ", confirmedTx);
            return confirmedTx;
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Creates an algosdk.Transaction object based on execParams and suggestedParams
     * @param execParams execParams containing all txn info
     * @param txParams suggestedParams object
     * @returns array of algosdk.Transaction objects
     */
    makeTx(execParams, txParams) {
        try {
            const txns = [];
            for (const [_, txn] of execParams.entries()) {
                txns.push((0, txn_1.mkTransaction)(txn, txParams));
            }
            return txns;
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Signes a Transaction object using walletconnect
     * @param transaction transaction object.
     * @returns SignedTransaction
     */
    async signTx(transaction) {
        try {
            const txns = [transaction];
            const txnsToSign = txns.map((txn) => {
                const encodedTxn = Buffer.from(algosdk_1.default.encodeUnsignedTransaction(txn)).toString("base64");
                return { txn: encodedTxn };
            });
            const requestParams = [txnsToSign];
            const request = (0, utils_1.formatJsonRpcRequest)(constants_1.ALGORAND_SIGN_TRANSACTION_REQUEST, requestParams);
            const result = await this.connector.sendCustomRequest(request);
            const decodedResult = result.map((element) => {
                return element ? new Uint8Array(Buffer.from(element, "base64")) : null;
            });
            if (decodedResult[0] === null) {
                throw new Error("Transaction was returned unsigned");
            }
            return algosdk_1.default.decodeSignedTransaction(decodedResult[0]);
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Creates an algosdk.Transaction object based on execParams and suggestedParams
     * and signs it using walletconnect
     * @param execParams execParams containing all txn info
     * @param txParams suggestedParams object
     * @returns array of algosdk.SignedTransaction objects
     */
    async makeAndSignTx(execParams, txParams) {
        try {
            const signedTxns = [];
            const txns = this.makeTx(execParams, txParams);
            for (const transaction of txns) {
                const signedTransaction = await this.signTx(transaction);
                signedTxns.push(signedTransaction);
            }
            return signedTxns;
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Sends signedTransaction and waits for the response
     * @param transactions array of signedTransaction objects.
     * @param rounds number of rounds to wait for response
     * @returns TxnReceipt which includes confirmed txn response along with txID
     */
    async sendTxAndWait(transactions, rounds) {
        try {
            if (transactions.length < 1) {
                throw Error("No transactions to process");
            }
            else {
                const Uint8ArraySignedTx = transactions.map((txn) => algosdk_1.default.encodeObj(txn));
                return await this.sendAndWait(Uint8ArraySignedTx, rounds);
            }
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
}
exports.WallectConnectSession = WallectConnectSession;
//# sourceMappingURL=wallectconnect-mode.js.map