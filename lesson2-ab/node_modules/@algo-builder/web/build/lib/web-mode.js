"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebMode = void 0;
const algosdk_1 = __importStar(require("algosdk"));
const errors_1 = require("../errors/errors");
const types_1 = require("../types");
const constants_1 = require("./constants");
const logger_1 = require("./logger");
const txn_1 = require("./txn");
const CONFIRMED_ROUND = "confirmed-round";
const LAST_ROUND = "last-round";
class WebMode {
    constructor(algoSigner, chainName) {
        this.algoSigner = algoSigner;
        this.chainName = chainName;
    }
    /**
     * wait for confirmation for transaction using transaction id
     * @param txId Transaction id
     * @param waitRounds number of rounds to wait for transaction to be confirmed - default is 10
     * @returns TxnReceipt which includes confirmed txn response along with txID
     */
    async waitForConfirmation(txId, waitRounds = constants_1.WAIT_ROUNDS) {
        try {
            const response = await this.algoSigner.algod({
                ledger: this.chainName,
                path: "/v2/status",
            });
            (0, logger_1.log)(response);
            const startRound = response[LAST_ROUND];
            let currentRound = startRound;
            // eslint-disable-next-line no-constant-condition
            while (currentRound < startRound + waitRounds) {
                const pendingInfo = await this.algoSigner.algod({
                    ledger: this.chainName,
                    path: `/v2/transactions/pending/${txId}`,
                });
                if (pendingInfo[CONFIRMED_ROUND] !== null &&
                    pendingInfo[CONFIRMED_ROUND] > 0) {
                    const txnReceipt = { txID: txId, ...pendingInfo };
                    return txnReceipt;
                }
                // TODO: maybe we should use "sleep" instead of pinging a node again?
                currentRound += 1;
                await this.algoSigner.algod({
                    ledger: this.chainName,
                    path: `/v2/status/wait-for-block-after/${currentRound}`, // eslint-disable-line @typescript-eslint/restrict-template-expressions
                });
            }
            throw new Error(`Transaction not confirmed after ${waitRounds} rounds`);
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Send signed transaction to network and wait for confirmation
     * @param signedTxn Signed Transaction blob encoded in base64
     * @param waitRounds number of rounds to wait for transaction to be confirmed - default is 10
     * @returns TxnReceipt which includes confirmed txn response along with txID
     */
    async sendAndWait(signedTxn, waitRounds = constants_1.WAIT_ROUNDS) {
        try {
            const txInfo = await this.algoSigner.send({
                ledger: this.chainName,
                tx: signedTxn,
            });
            if (txInfo && typeof txInfo.txId === "string") {
                return await this.waitForConfirmation(txInfo.txId, waitRounds);
            }
            throw new Error("Transaction Error");
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Send group transaction to network
     * @param signedTxs signed transaction group
     */
    async sendGroupTransaction(signedTxs) {
        try {
            // The AlgoSigner.signTxn() response would look like '[{ txID, blob }, null]'
            // Convert first transaction to binary from the response
            const signedTxBinary = signedTxs.map((txn) => {
                return this.algoSigner.encoding.base64ToMsgpack(txn.blob);
            });
            // Merge transaction binaries into a single Uint8Array
            const flatNumberArray = signedTxBinary.reduce((acc, curr) => {
                acc.push(...curr);
                return acc;
            }, []);
            const combinedBinaryTxns = new Uint8Array(flatNumberArray);
            // Convert the combined array values back to base64
            const combinedBase64Txns = this.algoSigner.encoding.msgpackToBase64(combinedBinaryTxns);
            return await this.algoSigner.send({
                ledger: this.chainName,
                tx: combinedBase64Txns,
            });
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Sign transaction using algosigner
     * @param txns Array of transactions in base64
     */
    async signTransaction(txns) {
        try {
            return await this.algoSigner.signTxn(txns);
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Returns suggested transaction parameters using algosigner
     * @param userParams Transaction parameters
     */
    async getSuggestedParams(userParams) {
        try {
            const txParams = await this.algoSigner.algod({
                ledger: this.chainName,
                path: "/v2/transactions/params",
            });
            const s = {
                fee: txParams.fee,
                genesisHash: txParams["genesis-hash"],
                genesisID: txParams["genesis-id"],
                firstRound: txParams[LAST_ROUND],
                lastRound: Number(txParams[LAST_ROUND]) + 1000,
                flatFee: false,
            };
            s.flatFee = userParams.totalFee !== undefined;
            s.fee = userParams.totalFee || userParams.feePerByte || txParams["min-fee"]; // eslint-disable-line @typescript-eslint/prefer-nullish-coalescing
            if (s.flatFee)
                s.fee = Math.max(Number(s.fee), Number(txParams["min-fee"]));
            s.firstRound = userParams.firstValid || s.firstRound; // eslint-disable-line @typescript-eslint/prefer-nullish-coalescing
            s.lastRound =
                userParams.firstValid === undefined || userParams.validRounds === undefined // eslint-disable-line @typescript-eslint/prefer-nullish-coalescing
                    ? s.lastRound
                    : Number(userParams.firstValid) + Number(userParams.validRounds);
            return s;
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Appends signature to a multisig transaction using algosigner
     * @param txn Multisignature Encoded Transaction
     * @param signers a subset of addresses to sign the transaction
     * return an object containing a blob key encoded in base64
     */
    async signMsigTx(txn, signers) {
        try {
            if (!txn.msig) {
                throw new Error("Current transaction is not a Multisig Transaction.");
            }
            const encodedTxn = this.algoSigner.encoding.msgpackToBase64((0, algosdk_1.encodeObj)(txn.txn));
            const mparams = txn.msig;
            const version = mparams.v;
            const threshold = mparams.thr;
            const addr = mparams.subsig.map((signData) => {
                return algosdk_1.default.encodeAddress(signData.pk);
            });
            const multisigParams = {
                version: version,
                threshold: threshold,
                addrs: addr,
            };
            const signedTxn = await this.signTransaction([
                {
                    txn: encodedTxn,
                    msig: multisigParams,
                    signers: signers,
                },
            ]);
            const signedTxnJson = signedTxn[0];
            let combineBlob = this.algoSigner.encoding.base64ToMsgpack(signedTxnJson.blob);
            // multiple signatures
            if (txn.msig?.subsig.findIndex((item) => item.s?.length) !== -1) {
                const blob1 = (0, algosdk_1.encodeObj)(txn);
                const blob2 = combineBlob;
                combineBlob = algosdk_1.default.mergeMultisigTransactions([blob1, blob2]);
            }
            const outputBase64 = this.algoSigner.encoding.msgpackToBase64(combineBlob);
            return {
                blob: outputBase64,
            };
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * @description Sign a Logic Signature transaction
     * @param transaction algosdk.Transaction object
     * @param logicSig Logic Sig Account
     * @returns Returns txID and blob object
     * for more info: https://developer.algorand.org/docs/get-details/dapps/smart-contracts/smartsigs/modes/#contract-account
     */
    signLogicSigTx(transaction, logicSig) {
        try {
            return algosdk_1.default.signLogicSigTransaction(transaction, logicSig);
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Execute single transaction or group of transactions (atomic transaction)
     * Check out {@link https://algobuilder.dev/guide/execute-transaction.html#execute-transaction|execute-transaction}
     * for more info.
     * @param transactions transaction parameters, atomic transaction parameters
     * or TransactionAndSign object(SDK transaction object and signer parameters).
     * When list of ExecParams is used, the function will request wallet to sign transactions.
     */
    /* eslint-disable sonarjs/cognitive-complexity */
    async executeTx(transactions) {
        try {
            let signedTxn;
            let txns = [];
            if (transactions.length > 16 || transactions.length == 0) {
                throw new errors_1.BuilderError(errors_1.ERRORS.GENERAL.TRANSACTION_LENGTH_ERROR, {
                    length: transactions.length,
                });
            }
            if ((0, types_1.isSDKTransactionAndSign)(transactions[0]))
                throw new Error("We don't support this case now");
            const execParams = transactions;
            for (const [_, txn] of execParams.entries()) {
                txns.push((0, txn_1.mkTransaction)(txn, await this.getSuggestedParams(txn.payFlags)));
            }
            txns = algosdk_1.default.assignGroupID(txns);
            const binaryTxs = txns.map((txn) => {
                return txn.toByte();
            });
            const base64Txs = binaryTxs.map((txn) => {
                return this.algoSigner.encoding.msgpackToBase64(txn);
            });
            // with logic signature we don't need signers.
            const toBeSignedTxns = base64Txs.map((txn, txnId) => {
                switch (execParams[txnId].sign) {
                    case types_1.SignType.LogicSignature:
                        return { txn: txn, signers: [] }; // logic signature
                    case types_1.SignType.MultiSignature: {
                        const msig = execParams[txnId];
                        return { txn: txn, msig: msig.mparams }; // multi singature
                    }
                    default:
                        return {
                            txn: txn,
                            authAddr: execParams[txnId].fromAccount?.addr || execParams[txnId].fromAccountAddr,
                        }; // set signer
                }
            });
            // checks if any sign txn exists else it throws error of empty signers array
            if (toBeSignedTxns.find((txn) => txn.authAddr)) {
                signedTxn = await this.signTransaction(toBeSignedTxns);
            }
            // sign smart signature transaction
            for (const [index, txn] of txns.entries()) {
                const signer = execParams[index];
                if (signer.sign === types_1.SignType.LogicSignature) {
                    signer.lsig.lsig.args = signer.args ? signer.args : [];
                    const lsigTxn = this.signLogicSigTx(txn, signer.lsig);
                    if (!Array.isArray(signedTxn))
                        signedTxn = []; // only logic signature txn are provided
                    signedTxn.splice(index, 0, {
                        blob: this.algoSigner.encoding.msgpackToBase64(lsigTxn.blob),
                        txID: lsigTxn.txID,
                    });
                }
            }
            signedTxn = signedTxn?.filter((stxn) => stxn);
            const txInfo = await this.sendGroupTransaction(signedTxn);
            if (txInfo && typeof txInfo.txId === "string") {
                return await this.waitForConfirmation(txInfo.txId);
            }
            throw new Error("Transaction Error");
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Creates an algosdk.Transaction object based on execParams and suggestedParams
     * @param execParams execParams containing all txn info
     * @param txParams suggestedParams object
     * @returns array of algosdk.Transaction objects
     */
    makeTx(execParams, txParams) {
        try {
            const txns = [];
            for (const [_, txn] of execParams.entries()) {
                txns.push((0, txn_1.mkTransaction)(txn, txParams));
            }
            return txns;
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Signs a Transaction object
     * @param transaction transaction object.
     * @returns SignedTransaction
     */
    async signTx(transaction) {
        try {
            const binaryTx = transaction.toByte();
            const base64Tx = this.algoSigner.encoding.msgpackToBase64(binaryTx);
            const signedTx = await this.signTransaction([
                {
                    txn: base64Tx,
                },
            ]);
            const blob = signedTx.blob;
            const blobArray = this.algoSigner.encoding.base64ToMsgpack(blob);
            return algosdk_1.default.decodeSignedTransaction(blobArray);
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Creates an algosdk.Transaction object based on execParams and suggestedParams
     * and signs it
     * @param execParams execParams containing all txn info
     * @param txParams suggestedParams object
     * @returns array of algosdk.SignedTransaction objects
     */
    async makeAndSignTx(execParams, txParams) {
        try {
            const signedTxns = [];
            const txns = this.makeTx(execParams, txParams);
            for (const transaction of txns) {
                const signedTransaction = await this.signTx(transaction);
                signedTxns.push(signedTransaction);
            }
            return signedTxns;
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
    /**
     * Sends signedTransaction and waits for the response
     * @param transactions array of signedTransaction objects.
     * @param rounds number of rounds to wait for response
     * @returns TxnReceipt which includes confirmed txn response along with txID
     */
    async sendTxAndWait(transactions, rounds) {
        try {
            if (transactions.length < 1) {
                throw new Error("No transactions to process");
            }
            else {
                const txInfo = await this.sendGroupTransaction(transactions);
                if (txInfo && typeof txInfo.txId === "string") {
                    return await this.waitForConfirmation(txInfo.txId, rounds);
                }
                throw new Error("Transaction Incorrect");
            }
        }
        catch (err) {
            (0, logger_1.error)(err);
            throw err;
        }
    }
}
exports.WebMode = WebMode;
//# sourceMappingURL=web-mode.js.map