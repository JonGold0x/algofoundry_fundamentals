"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runMultipleScripts = exports.splitAfter = exports.filterNonExistent = void 0;
const web_1 = require("@algo-builder/web");
const chalk_1 = __importDefault(require("chalk"));
const debug_1 = __importDefault(require("debug"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const config_env_1 = require("../internal/core/config/config-env");
const deployer_cfg_1 = require("../internal/deployer_cfg");
const tx_log_writer_1 = require("../internal/tx-log-writer");
const lists_1 = require("../internal/util/lists");
const scripts_runner_1 = require("../internal/util/scripts-runner");
const algo_operator_1 = require("../lib/algo-operator");
const comparators_1 = require("../lib/comparators");
const files_1 = require("../lib/files");
const script_checkpoints_1 = require("../lib/script-checkpoints");
const task_names_1 = require("./task-names");
function filterNonExistent(scripts) {
    return scripts.filter((script) => !fs_extra_1.default.pathExistsSync(script));
}
exports.filterNonExistent = filterNonExistent;
// returns all items before the current one and
// mutates the original array to remove them
function splitAfter(scriptsFromScriptsDir, splitAfterScript) {
    for (let i = 0; i < scriptsFromScriptsDir.length; i++) {
        const scriptName = scriptsFromScriptsDir[i];
        if (scriptName === splitAfterScript) {
            return scriptsFromScriptsDir.splice(0, i + 1);
        }
    }
    return scriptsFromScriptsDir.splice(0, scriptsFromScriptsDir.length);
}
exports.splitAfter = splitAfter;
/** Partitions an unsorted string list into sorted parts:
        `[1 2 2 3 4 3 4 2 1]` returns `[[1 2 2 3 4] [3 4] [2] [1]]` */
function partitionIntoSorted(unsorted) {
    return (0, lists_1.partitionByFn)((a, b) => (0, comparators_1.cmpStr)(a, b) === 1, // split when a > b
    unsorted);
}
async function runMultipleScripts(runtimeEnv, scriptNames, arg, onSuccessFn, force, logDebugTag, allowWrite, algoOp) {
    const deployerCfg = new deployer_cfg_1.DeployerConfig(runtimeEnv, algoOp);
    for (const scripts of partitionIntoSorted(scriptNames)) {
        await runScripts(runtimeEnv, scripts, arg, onSuccessFn, force, logDebugTag, allowWrite, deployerCfg);
    }
}
exports.runMultipleScripts = runMultipleScripts;
// Function only accepts sorted scripts -- only this way it loads the state correctly.
async function runScripts(runtimeEnv, scriptNames, arg, onSuccessFn, force, logDebugTag, allowWrite, deployerCfg) {
    const log = (0, debug_1.default)(logDebugTag);
    deployerCfg.cpData = (0, script_checkpoints_1.loadCheckpointsRecursive)();
    deployerCfg.txWriter = new tx_log_writer_1.TxWriterImpl("");
    const deployer = (0, deployer_cfg_1.mkDeployer)(allowWrite, deployerCfg);
    const scriptsFromScriptsDir = (0, script_checkpoints_1.lsScriptsDir)();
    for (const relativeScriptPath of scriptNames) {
        const prevScripts = splitAfter(scriptsFromScriptsDir, relativeScriptPath);
        (0, script_checkpoints_1.loadCheckpointsIntoCPData)(deployerCfg.cpData, prevScripts);
        if (prevScripts[prevScripts.length - 1] !== relativeScriptPath) {
            deployerCfg.cpData.merge((0, script_checkpoints_1.loadCheckpoint)(relativeScriptPath), relativeScriptPath);
        }
        if (!force && deployerCfg.cpData.networkExistsInCurrentCP(runtimeEnv.network.name)) {
            log(`Skipping: Checkpoint exists for script ${relativeScriptPath}`);
            // '\x1b[33m%s\x1b[0m' this is used for setting the message color to yellow.
            console.warn(chalk_1.default.yellowBright(`Skipping: Checkpoint exists for script ${relativeScriptPath}`));
            continue;
        }
        deployerCfg.txWriter.setScriptName(relativeScriptPath);
        log(`Running script ${relativeScriptPath}`);
        await (0, scripts_runner_1.runScript)(relativeScriptPath, arg, runtimeEnv, deployer);
        onSuccessFn(deployerCfg.cpData, relativeScriptPath);
    }
}
const isValidJsonString = (str) => {
    try {
        JSON.parse(str);
    }
    catch (e) {
        return false;
    }
    return true;
};
async function executeRunTask({ script, arg }, runtimeEnv, algoOp) {
    const logDebugTag = "algob:tasks:run";
    let scriptName;
    if (arg && !isValidJsonString(arg)) {
        throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.RUN_ARGUMENT_INVALID, {
            jsonString: arg
        });
    }
    if (script && script.length) {
        // get script from script array, first element should be script
        scriptName = script[0];
    }
    if (scriptName) {
        const nonExistent = filterNonExistent([scriptName]);
        if (nonExistent.length !== 0) {
            throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.RUN_FILES_NOT_FOUND, {
                scripts: nonExistent,
            });
        }
        (0, files_1.assertDirChildren)(script_checkpoints_1.scriptsDirectory, [scriptName]);
        const deployerCfg = new deployer_cfg_1.DeployerConfig(runtimeEnv, algoOp);
        await runScripts(runtimeEnv, [scriptName], arg, (_cpData, _relativeScriptPath) => { }, // eslint-disable-line @typescript-eslint/no-empty-function
        true, logDebugTag, false, deployerCfg);
    }
    else {
        throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.RUN_FILE_NOT_FOUND_WITH_SUGGESTION);
    }
}
function default_1() {
    (0, config_env_1.task)(task_names_1.TASK_RUN, `Runs a user-defined script after compiling the project\n\nExample: yarn algob run script.js --arg '{"firstname":"Jesper","surname":"Aaberg"}'`)
        .addVariadicPositionalParam("script", "A script file to be run within algob's environment.")
        .addOptionalParam("arg", "Argument in JSON string to be passed in the script.")
        .setAction((input, env) => executeRunTask(input, env, (0, algo_operator_1.createAlgoOperator)(env.network)));
}
exports.default = default_1;
//# sourceMappingURL=run.js.map